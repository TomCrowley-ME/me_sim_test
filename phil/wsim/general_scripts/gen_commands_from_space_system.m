%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright 2010 - 2015 Moon Express, Inc.
% All Rights Reserved.
%
% PROPRIETARY DATA NOTICE:
% The data herein include Proprietary Data and are restricted under the
% Data Rights provisions of Lunar CATALYST Space Act Agreement
% No. SAAM ID# 18251 and Reimbursable Space Act Agreement No.SAA2-402930.
% All information contained herein is and remains proprietary to and the
% property of Moon Express, Inc. Dissemination of this information or
% reproduction of this material is strictly forbidden unless prior
% written permission is obtained from Moon Express, Inc.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% gen_commands_from_space_system.m
% Reads the supplied space system (which is assumed to be the root node of
% the dictionary) and writes out a script that creates command and
% parameter type maps for the load_scenario STOL parsing

function gen_commands_from_space_system(root_space_system, target_space_systems, filename)

fprintf(1,'Writing %s command and type maps to %s...\n', strjoin(target_space_systems, ' & '), filename);
% Determine function name and open file
[~, functionname] = fileparts(filename);
fid = fopen(filename, 'w+');

% Write out autogeneration notice and description header

header = [ ...
    '%%%% ' functionname '.m\n' ...
    '%% AUTOGENERATED -- DO NOT EDIT\n' ...
    '%% Creates command and parameter type maps for use in STOL parsing.\n' ...
    '%%\n' ...
    '\n' ...
    ];

fprintf(fid, header);

% Start with creating the command map
fprintf(fid, 'fsw_commands = containers.Map(');

% Even though we get the name of a command and its definition at the same
% time, static map definitions come in the form of a key cell array,
% followed by a value cell array. To this end, we need to build up two
% separate buffers for printing (a key buffer and a value buffer), and then
% print them sequentially.
command_key_str = '{ ...\n';
command_value_str = '{ ...\n';
for i=1:length(target_space_systems)
    load_all_commands(root_space_system, target_space_systems{i});
end
command_key_str = [command_key_str '},'];
command_value_str = [command_value_str '}'];

fprintf(fid, command_key_str);
fprintf(fid, command_value_str);
fprintf(fid, ');\n\n');

% Same goes for the type map
fprintf(fid, 'fsw_parameter_types = containers.Map(');
type_key_str = '{ ...\n';
type_value_str = '{ ...\n';
for i=1:length(target_space_systems)
    load_all_parameter_types(root_space_system, target_space_systems{i});
end
type_key_str = [type_key_str '},'];
type_value_str = [type_value_str '}'];

fprintf(fid, type_key_str);
fprintf(fid, type_value_str);
fprintf(fid, ');\n\n');

% Hacky: Make an array of allowed msgids based on known commands and
% vehicles
fprintf(fid, 'sc_desired_msgids = [ ...\n');
fprintf(fid, '    fsw_commands(''cmp_reset'').msgid ...\n');
fprintf(fid, '    fsw_commands(''sc_startrts'').msgid ...\n');
fprintf(fid, '    fsw_commands(''lc_set_actionpoint_state'').msgid ...\n');

fprintf(fid, '];\n');

% All done!
fclose(fid);

    % Takes a command sequence container and appends its name and structure
    % information to the proper print buffers
    function emit_command(command_container)
        % We're only looking for "well-defined" commands, ie, those that
        % have an associated APID and command code
        apid = -1;
        command_code = -1;
        
        for j=1:length(command_container.base.restriction_criteria)
            criterion = command_container.base.restriction_criteria{j};
            switch criterion.parameter_ref
                case 'apid'
                    apid = criterion.value;
                case 'cmd_function_code'
                    command_code = criterion.value;
            end
        end
        if apid == -1 || command_code == -1
            return;
        end
        
        % Add the name of the command to the names buffer
        command_key_str = [command_key_str '    ''' command_container.name ''', ...\n'];
        
        % Add the command's information to the values buffer
        command_value_str = [command_value_str sprintf('    struct(''msgid'', %u, ''command_code'', %u, ''parameters'', {{', apid+hex2dec('1800'), command_code)];
        for j=1:length(command_container.parameters)
            param = command_container.parameters{j};
            command_value_str = [command_value_str sprintf('struct(''name'', ''%s'', ''type'', ''%s''),', param.name, param.type)];
        end
        command_value_str = [command_value_str sprintf('}}), ... %%%% %s\n', command_container.name)];
    end

    function process_space_system_commands(space_system)
        if isfield(space_system, 'command_data')
            % Look through this system's command sequence containers
            for j=1:length(space_system.command_data.sequence_containers)
                command_container = space_system.command_data.sequence_containers{j};
                
                % We're specifically looking for non-abstract containers
                % with restriction criteria containing an APID
                if ~command_container.abstract && isfield(command_container, 'base') && isfield(command_container.base, 'restriction_criteria')
                    emit_command(command_container);
                end
            end
        end
    end

    % Recurses through the supplied space system, calling emit_command on
    % each found command sequence container
    function found = load_all_commands(space_system, target_name)
        found = 0;
        
        if strcmp(space_system.name, target_name)
            process_space_system_commands(space_system);
            found = 1;
        elseif isfield(space_system, 'sub_systems')
            for j=1:length(space_system.sub_systems)
                if load_all_commands(space_system.sub_systems{j}, target_name)
                    process_space_system_commands(space_system);
                    found = 1;
                    return;
                end
            end
        end
    end

    function emit_type(parameter_type)
        % Don't care about strings or pointers for the wsim
        if strcmp(parameter_type.base_type, 'string') || strcmp(parameter_type.base_type, 'pointer')
            return;
        end
        
        % Add the type's name to the name buffer
        type_key_str = [type_key_str '    ''' parameter_type.name ''', ...\n'];
        
        % And add its defining characteristics to the values buffer
        type_value_str = [type_value_str sprintf('    struct(''base_type'', ''%s'', ''size_in_bits'', %u', parameter_type.base_type, parameter_type.size_in_bits)];
        

        if strcmp(parameter_type.base_type, 'integer')
            % Integers can be either signed or unsigned
            type_value_str = [type_value_str sprintf(', ''signed'', %u', parameter_type.signed)];
        end
        
        if isfield(parameter_type, 'enumeration_list')
            % If we've got an enumeration on our hands, we need to define all
            % valid label-value pairs
            type_value_str = [type_value_str ', ''enumeration_list'', {{'];
            for j=1:length(parameter_type.enumeration_list)
                enum_entry = parameter_type.enumeration_list{j};
                type_value_str = [type_value_str sprintf('struct(''label'', ''%s'', ''value'', %d),', enum_entry.label, enum_entry.value)];
            end
            type_value_str = [type_value_str '}}'];
        end
        type_value_str = [type_value_str sprintf('); ... %%%% %s\n', parameter_type.name)];
    end

    function process_space_system_types(space_system) 
        % Does this space system have associated parameter_types?
        if isfield(space_system, 'common_data') && isfield(space_system.common_data, 'parameter_types')
            for j=1:length(space_system.common_data.parameter_types);
                emit_type(space_system.common_data.parameter_types{j});
            end
        end
    end
        
        
    % Recurses through the supplied space system, calling the type
    % processing function on the target and all of its parents
    function found = load_all_parameter_types(space_system, target_name)
        found = 0;
        
        if strcmp(space_system.name, target_name)
            process_space_system_types(space_system);
            found = 1;
        elseif isfield(space_system, 'sub_systems')
            for j=1:length(space_system.sub_systems)
                if load_all_parameter_types(space_system.sub_systems{j}, target_name)
                    process_space_system_types(space_system);
                    found = 1;
                    return;
                end
            end
        end
    end
end
