# tcInfo_gnu.tcl - generated by tcInfoGen.tcl


package require Wind 1.1

# toolchain : ARMARCH4_Tgnu
# toolchain : ARMARCH4_Tgnube
# toolchain : ARMARCH4gnu
# toolchain : ARMARCH4gnube
# toolchain : ARMARCH5_Tgnu
# toolchain : ARMARCH5_Tgnube
# toolchain : ARMARCH5gnu
# toolchain : ARMARCH5gnube
# toolchain : CPU32gnu
# toolchain : FR500gnu
# toolchain : I80386gnu
# toolchain : I80486gnu
# toolchain : MC68000gnu
# toolchain : MC68010gnu
# toolchain : MC68020gnu
# toolchain : MC68040gnu
# toolchain : MC68060gnu
# toolchain : MC68LC040gnu
# toolchain : MCORE15gnu
# toolchain : PENTIUM2gnu
# toolchain : PENTIUM3gnu
# toolchain : PENTIUM4gnu
# toolchain : PENTIUMgnu
# toolchain : PPC32gnu
# toolchain : PPC403gnu
# toolchain : PPC405gnu
# toolchain : PPC440gnu
# toolchain : PPC603gnu
# toolchain : PPC604gnu
# toolchain : PPC860gnu
# toolchain : SH7600gnu
# toolchain : SH7700gnu
# toolchain : SH7700gnule
# toolchain : SH7750gnu
# toolchain : SH7750gnule
# toolchain : SIMLINUXgnu
# toolchain : SIMNTgnu
# toolchain : SIMSPARCSOLARISgnu
# toolchain : XSCALEgnu
# toolchain : XSCALEgnube
# toolchain : PPC32sfgnu
# toolchain : PPC405sfgnu
# toolchain : PPC440sfgnu
# toolchain : PPC85XXgnu
# toolchain : PPC85XXsfgnu
# toolchain : ARMARCH6gnu
# toolchain : ARMARCH6gnube
# toolchain : PPC970gnu
# toolchain : PPC860sfgnu
# toolchain : MIPSI2sfgnu
# toolchain : MIPSI2sfgnule
# toolchain : MIPSI32R2gnu
# toolchain : MIPSI32R2gnule
# toolchain : MIPSI32R2sfgnu
# toolchain : MIPSI32R2sfgnule
# toolchain : MIPSI32gnu
# toolchain : MIPSI32gnule
# toolchain : MIPSI32sfgnu
# toolchain : MIPSI32sfgnule
# toolchain : MIPSI3gnu
# toolchain : MIPSI3gnule
# toolchain : MIPSI64R2gnu
# toolchain : MIPSI64R2gnule
# toolchain : MIPSI64R2sfgnu
# toolchain : MIPSI64R2sfgnule
# toolchain : MIPSI64gnu
# toolchain : MIPSI64gnule
# toolchain : MIPSI64sfgnu
# toolchain : MIPSI64sfgnule
# toolchain : PPC32e500v2gnu
# toolchain : PPC85XXe500v2gnu
# toolchain : MIPSI2gnu

namespace eval tcInfo {}
	lappend tcInfo::ToolFamilies(ARMARCH4) gnu
	lappend tcInfo::ToolFamilies(ARMARCH4_T) gnu
	lappend tcInfo::ToolFamilies(ARMARCH5) gnu
	lappend tcInfo::ToolFamilies(ARMARCH5_T) gnu
	lappend tcInfo::ToolFamilies(ARMARCH6) gnu
	lappend tcInfo::ToolFamilies(CPU32) gnu
	lappend tcInfo::ToolFamilies(FR500) gnu
	lappend tcInfo::ToolFamilies(I80386) gnu
	lappend tcInfo::ToolFamilies(I80486) gnu
	lappend tcInfo::ToolFamilies(MC68000) gnu
	lappend tcInfo::ToolFamilies(MC68010) gnu
	lappend tcInfo::ToolFamilies(MC68020) gnu
	lappend tcInfo::ToolFamilies(MC68040) gnu
	lappend tcInfo::ToolFamilies(MC68060) gnu
	lappend tcInfo::ToolFamilies(MC68LC040) gnu
	lappend tcInfo::ToolFamilies(MCORE15) gnu
	lappend tcInfo::ToolFamilies(MIPSI2) gnu
	lappend tcInfo::ToolFamilies(MIPSI3) gnu
	lappend tcInfo::ToolFamilies(MIPSI32) gnu
	lappend tcInfo::ToolFamilies(MIPSI32R2) gnu
	lappend tcInfo::ToolFamilies(MIPSI64) gnu
	lappend tcInfo::ToolFamilies(MIPSI64R2) gnu
	lappend tcInfo::ToolFamilies(PENTIUM) gnu
	lappend tcInfo::ToolFamilies(PENTIUM2) gnu
	lappend tcInfo::ToolFamilies(PENTIUM3) gnu
	lappend tcInfo::ToolFamilies(PENTIUM4) gnu
	lappend tcInfo::ToolFamilies(PPC32) gnu
	lappend tcInfo::ToolFamilies(PPC403) gnu
	lappend tcInfo::ToolFamilies(PPC405) gnu
	lappend tcInfo::ToolFamilies(PPC440) gnu
	lappend tcInfo::ToolFamilies(PPC603) gnu
	lappend tcInfo::ToolFamilies(PPC604) gnu
	lappend tcInfo::ToolFamilies(PPC85XX) gnu
	lappend tcInfo::ToolFamilies(PPC860) gnu
	lappend tcInfo::ToolFamilies(PPC970) gnu
	lappend tcInfo::ToolFamilies(SH7600) gnu
	lappend tcInfo::ToolFamilies(SH7700) gnu
	lappend tcInfo::ToolFamilies(SH7750) gnu
	lappend tcInfo::ToolFamilies(SIMLINUX) gnu
	lappend tcInfo::ToolFamilies(SIMNT) gnu
	lappend tcInfo::ToolFamilies(SIMSPARCSOLARIS) gnu
	lappend tcInfo::ToolFamilies(XSCALE) gnu
	lappend tcInfo::ToolFamilies(SPARC) gnu
set tcInfo_ARMARCH4_Tgnu(TOOL_FAMILY) gnu
set tcInfo_ARMARCH4_Tgnu(CC) "ccarm"
set tcInfo_ARMARCH4_Tgnu(CPP) "ccarm -E -P"
set tcInfo_ARMARCH4_Tgnu(AS) "ccarm"
set tcInfo_ARMARCH4_Tgnu(LD) "ldarm"
set tcInfo_ARMARCH4_Tgnu(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EL"
set tcInfo_ARMARCH4_Tgnu(NM) "nmarm -g"
set tcInfo_ARMARCH4_Tgnu(SIZE) "sizearm"
set tcInfo_ARMARCH4_Tgnu(AR) "ararm"
set tcInfo_ARMARCH4_Tgnu(CFLAGS) {-g -t4t -ansi -fno-builtin -Wall -DARMEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH4_Tgnu(CFLAGS_AS) {-g -t4t -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH4_Tgnu(LDFLAGS) "-X -EL -N"
set tcInfo_ARMARCH4_Tgnu(LD_PARTIAL_FLAGS) "-X -EL -r"
set tcInfo_ARMARCH4_Tgnu(HEX_FLAGS) ""
set tcInfo_ARMARCH4_Tgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_ARMARCH4_Tgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_ARMARCH4_Tgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_ARMARCH4_Tgnu(OPTION_LANG_C) -xc
set tcInfo_ARMARCH4_Tgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_ARMARCH4_Tgnu(OPTION_DEPEND) "-M -w"
set tcInfo_ARMARCH4_Tgnu(CC_ARCH_SPEC) "-t4t"
namespace eval ::tc_ARMARCH4_Tgnu { }

set tc_ARMARCH4_Tgnu::tcname(little_soft) gnu

namespace eval ::tc_ARMARCH4_Tgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_ARMARCH4_Tgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_ARMARCH4_Tgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_ARMARCH4_Tgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return ARMARCH4_T
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return ARMARCH4_Tgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_ARMARCH4_Tgnu
}
set tcInfo_ARMARCH4_Tgnube(TOOL_FAMILY) gnu
set tcInfo_ARMARCH4_Tgnube(CC) "ccarm"
set tcInfo_ARMARCH4_Tgnube(CPP) "ccarm -E -P"
set tcInfo_ARMARCH4_Tgnube(AS) "ccarm"
set tcInfo_ARMARCH4_Tgnube(LD) "ldarm"
set tcInfo_ARMARCH4_Tgnube(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EB"
set tcInfo_ARMARCH4_Tgnube(NM) "nmarm -g"
set tcInfo_ARMARCH4_Tgnube(SIZE) "sizearm"
set tcInfo_ARMARCH4_Tgnube(AR) "ararm"
set tcInfo_ARMARCH4_Tgnube(CFLAGS) {-g -t4tbe -Wa,-EB -ansi -fno-builtin -Wall -DARMEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH4_Tgnube(CFLAGS_AS) {-g -t4tbe -Wa,-EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH4_Tgnube(LDFLAGS) "-X -EB -N"
set tcInfo_ARMARCH4_Tgnube(LD_PARTIAL_FLAGS) "-X -EB -r"
set tcInfo_ARMARCH4_Tgnube(HEX_FLAGS) ""
set tcInfo_ARMARCH4_Tgnube(OPTION_INCLUDE_DIR) -I
set tcInfo_ARMARCH4_Tgnube(OPTION_DEFINE_MACRO) -D
set tcInfo_ARMARCH4_Tgnube(OPTION_UNDEFINE_MACRO) -U
set tcInfo_ARMARCH4_Tgnube(OPTION_LANG_C) -xc
set tcInfo_ARMARCH4_Tgnube(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_ARMARCH4_Tgnube(OPTION_DEPEND) "-M -w"
set tcInfo_ARMARCH4_Tgnube(CC_ARCH_SPEC) "-t4tbe -Wa,-EB"
namespace eval ::tc_ARMARCH4_Tgnu { }

set tc_ARMARCH4_Tgnu::tcname(big_soft) gnube

namespace eval ::tc_ARMARCH4_Tgnube::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_ARMARCH4_Tgnube::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_ARMARCH4_Tgnube::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_ARMARCH4_Tgnube {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnube
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return ARMARCH4_T
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return ARMARCH4_Tgnube
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_ARMARCH4_Tgnube
}
set tcInfo_ARMARCH4gnu(TOOL_FAMILY) gnu
set tcInfo_ARMARCH4gnu(CC) "ccarm"
set tcInfo_ARMARCH4gnu(CPP) "ccarm -E -P"
set tcInfo_ARMARCH4gnu(AS) "ccarm"
set tcInfo_ARMARCH4gnu(LD) "ldarm"
set tcInfo_ARMARCH4gnu(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EL"
set tcInfo_ARMARCH4gnu(NM) "nmarm -g"
set tcInfo_ARMARCH4gnu(SIZE) "sizearm"
set tcInfo_ARMARCH4gnu(AR) "ararm"
set tcInfo_ARMARCH4gnu(CFLAGS) {-g -t4 -ansi -fno-builtin -Wall -DARMEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH4gnu(CFLAGS_AS) {-g -t4 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH4gnu(LDFLAGS) "-X -EL -N"
set tcInfo_ARMARCH4gnu(LD_PARTIAL_FLAGS) "-X -EL -r"
set tcInfo_ARMARCH4gnu(HEX_FLAGS) ""
set tcInfo_ARMARCH4gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_ARMARCH4gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_ARMARCH4gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_ARMARCH4gnu(OPTION_LANG_C) -xc
set tcInfo_ARMARCH4gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_ARMARCH4gnu(OPTION_DEPEND) "-M -w"
set tcInfo_ARMARCH4gnu(CC_ARCH_SPEC) "-t4"
namespace eval ::tc_ARMARCH4gnu { }

set tc_ARMARCH4gnu::tcname(little_soft) gnu

namespace eval ::tc_ARMARCH4gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_ARMARCH4gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_ARMARCH4gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_ARMARCH4gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return ARMARCH4
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return ARMARCH4gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_ARMARCH4gnu
}
set tcInfo_ARMARCH4gnube(TOOL_FAMILY) gnu
set tcInfo_ARMARCH4gnube(CC) "ccarm"
set tcInfo_ARMARCH4gnube(CPP) "ccarm -E -P"
set tcInfo_ARMARCH4gnube(AS) "ccarm"
set tcInfo_ARMARCH4gnube(LD) "ldarm"
set tcInfo_ARMARCH4gnube(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EB"
set tcInfo_ARMARCH4gnube(NM) "nmarm -g"
set tcInfo_ARMARCH4gnube(SIZE) "sizearm"
set tcInfo_ARMARCH4gnube(AR) "ararm"
set tcInfo_ARMARCH4gnube(CFLAGS) {-g -t4be -Wa,-EB -ansi -fno-builtin -Wall -DARMEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH4gnube(CFLAGS_AS) {-g -t4be -Wa,-EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH4gnube(LDFLAGS) "-X -EB -N"
set tcInfo_ARMARCH4gnube(LD_PARTIAL_FLAGS) "-X -EB -r"
set tcInfo_ARMARCH4gnube(HEX_FLAGS) ""
set tcInfo_ARMARCH4gnube(OPTION_INCLUDE_DIR) -I
set tcInfo_ARMARCH4gnube(OPTION_DEFINE_MACRO) -D
set tcInfo_ARMARCH4gnube(OPTION_UNDEFINE_MACRO) -U
set tcInfo_ARMARCH4gnube(OPTION_LANG_C) -xc
set tcInfo_ARMARCH4gnube(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_ARMARCH4gnube(OPTION_DEPEND) "-M -w"
set tcInfo_ARMARCH4gnube(CC_ARCH_SPEC) "-t4be -Wa,-EB"
namespace eval ::tc_ARMARCH4gnu { }

set tc_ARMARCH4gnu::tcname(big_soft) gnube

namespace eval ::tc_ARMARCH4gnube::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_ARMARCH4gnube::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_ARMARCH4gnube::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_ARMARCH4gnube {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnube
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return ARMARCH4
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return ARMARCH4gnube
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_ARMARCH4gnube
}
set tcInfo_ARMARCH5_Tgnu(TOOL_FAMILY) gnu
set tcInfo_ARMARCH5_Tgnu(CC) "ccarm"
set tcInfo_ARMARCH5_Tgnu(CPP) "ccarm -E -P"
set tcInfo_ARMARCH5_Tgnu(AS) "ccarm"
set tcInfo_ARMARCH5_Tgnu(LD) "ldarm"
set tcInfo_ARMARCH5_Tgnu(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EL"
set tcInfo_ARMARCH5_Tgnu(NM) "nmarm -g"
set tcInfo_ARMARCH5_Tgnu(SIZE) "sizearm"
set tcInfo_ARMARCH5_Tgnu(AR) "ararm"
set tcInfo_ARMARCH5_Tgnu(CFLAGS) {-g -t5t -ansi -fno-builtin -Wall -DARMEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH5_Tgnu(CFLAGS_AS) {-g -t5t -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH5_Tgnu(LDFLAGS) "-X -EL -N"
set tcInfo_ARMARCH5_Tgnu(LD_PARTIAL_FLAGS) "-X -EL -r"
set tcInfo_ARMARCH5_Tgnu(HEX_FLAGS) ""
set tcInfo_ARMARCH5_Tgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_ARMARCH5_Tgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_ARMARCH5_Tgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_ARMARCH5_Tgnu(OPTION_LANG_C) -xc
set tcInfo_ARMARCH5_Tgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_ARMARCH5_Tgnu(OPTION_DEPEND) "-M -w"
set tcInfo_ARMARCH5_Tgnu(CC_ARCH_SPEC) "-t5t"
namespace eval ::tc_ARMARCH5_Tgnu { }

set tc_ARMARCH5_Tgnu::tcname(little_soft) gnu

namespace eval ::tc_ARMARCH5_Tgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_ARMARCH5_Tgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_ARMARCH5_Tgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_ARMARCH5_Tgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return ARMARCH5_T
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return ARMARCH5_Tgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_ARMARCH5_Tgnu
}
set tcInfo_ARMARCH5_Tgnube(TOOL_FAMILY) gnu
set tcInfo_ARMARCH5_Tgnube(CC) "ccarm"
set tcInfo_ARMARCH5_Tgnube(CPP) "ccarm -E -P"
set tcInfo_ARMARCH5_Tgnube(AS) "ccarm"
set tcInfo_ARMARCH5_Tgnube(LD) "ldarm"
set tcInfo_ARMARCH5_Tgnube(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EB"
set tcInfo_ARMARCH5_Tgnube(NM) "nmarm -g"
set tcInfo_ARMARCH5_Tgnube(SIZE) "sizearm"
set tcInfo_ARMARCH5_Tgnube(AR) "ararm"
set tcInfo_ARMARCH5_Tgnube(CFLAGS) {-g -t5tbe -Wa,-EB -ansi -fno-builtin -Wall -DARMEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH5_Tgnube(CFLAGS_AS) {-g -t5tbe -Wa,-EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH5_Tgnube(LDFLAGS) "-X -EB -N"
set tcInfo_ARMARCH5_Tgnube(LD_PARTIAL_FLAGS) "-X -EB -r"
set tcInfo_ARMARCH5_Tgnube(HEX_FLAGS) ""
set tcInfo_ARMARCH5_Tgnube(OPTION_INCLUDE_DIR) -I
set tcInfo_ARMARCH5_Tgnube(OPTION_DEFINE_MACRO) -D
set tcInfo_ARMARCH5_Tgnube(OPTION_UNDEFINE_MACRO) -U
set tcInfo_ARMARCH5_Tgnube(OPTION_LANG_C) -xc
set tcInfo_ARMARCH5_Tgnube(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_ARMARCH5_Tgnube(OPTION_DEPEND) "-M -w"
set tcInfo_ARMARCH5_Tgnube(CC_ARCH_SPEC) "-t5tbe  -Wa,-EB"
namespace eval ::tc_ARMARCH5_Tgnu { }

set tc_ARMARCH5_Tgnu::tcname(big_soft) gnube

namespace eval ::tc_ARMARCH5_Tgnube::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_ARMARCH5_Tgnube::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_ARMARCH5_Tgnube::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_ARMARCH5_Tgnube {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnube
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return ARMARCH5_T
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return ARMARCH5_Tgnube
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_ARMARCH5_Tgnube
}
set tcInfo_ARMARCH5gnu(TOOL_FAMILY) gnu
set tcInfo_ARMARCH5gnu(CC) "ccarm"
set tcInfo_ARMARCH5gnu(CPP) "ccarm -E -P"
set tcInfo_ARMARCH5gnu(AS) "ccarm"
set tcInfo_ARMARCH5gnu(LD) "ldarm"
set tcInfo_ARMARCH5gnu(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EL"
set tcInfo_ARMARCH5gnu(NM) "nmarm -g"
set tcInfo_ARMARCH5gnu(SIZE) "sizearm"
set tcInfo_ARMARCH5gnu(AR) "ararm"
set tcInfo_ARMARCH5gnu(CFLAGS) {-g -t5 -ansi -fno-builtin -Wall -DARMEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH5gnu(CFLAGS_AS) {-g -t5 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH5gnu(LDFLAGS) "-X -EL -N"
set tcInfo_ARMARCH5gnu(LD_PARTIAL_FLAGS) "-X -EL -r"
set tcInfo_ARMARCH5gnu(HEX_FLAGS) ""
set tcInfo_ARMARCH5gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_ARMARCH5gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_ARMARCH5gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_ARMARCH5gnu(OPTION_LANG_C) -xc
set tcInfo_ARMARCH5gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_ARMARCH5gnu(OPTION_DEPEND) "-M -w"
set tcInfo_ARMARCH5gnu(CC_ARCH_SPEC) "-t5"
namespace eval ::tc_ARMARCH5gnu { }

set tc_ARMARCH5gnu::tcname(little_soft) gnu

namespace eval ::tc_ARMARCH5gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_ARMARCH5gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_ARMARCH5gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_ARMARCH5gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return ARMARCH5
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return ARMARCH5gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_ARMARCH5gnu
}
set tcInfo_ARMARCH5gnube(TOOL_FAMILY) gnu
set tcInfo_ARMARCH5gnube(CC) "ccarm"
set tcInfo_ARMARCH5gnube(CPP) "ccarm -E -P"
set tcInfo_ARMARCH5gnube(AS) "ccarm"
set tcInfo_ARMARCH5gnube(LD) "ldarm"
set tcInfo_ARMARCH5gnube(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EB"
set tcInfo_ARMARCH5gnube(NM) "nmarm -g"
set tcInfo_ARMARCH5gnube(SIZE) "sizearm"
set tcInfo_ARMARCH5gnube(AR) "ararm"
set tcInfo_ARMARCH5gnube(CFLAGS) {-g -t5be -Wa,-EB -ansi -fno-builtin -Wall -DARMEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH5gnube(CFLAGS_AS) {-g -t5be -Wa,-EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH5gnube(LDFLAGS) "-X -EB -N"
set tcInfo_ARMARCH5gnube(LD_PARTIAL_FLAGS) "-X -EB -r"
set tcInfo_ARMARCH5gnube(HEX_FLAGS) ""
set tcInfo_ARMARCH5gnube(OPTION_INCLUDE_DIR) -I
set tcInfo_ARMARCH5gnube(OPTION_DEFINE_MACRO) -D
set tcInfo_ARMARCH5gnube(OPTION_UNDEFINE_MACRO) -U
set tcInfo_ARMARCH5gnube(OPTION_LANG_C) -xc
set tcInfo_ARMARCH5gnube(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_ARMARCH5gnube(OPTION_DEPEND) "-M -w"
set tcInfo_ARMARCH5gnube(CC_ARCH_SPEC) "-t5be  -Wa,-EB"
namespace eval ::tc_ARMARCH5gnu { }

set tc_ARMARCH5gnu::tcname(big_soft) gnube

namespace eval ::tc_ARMARCH5gnube::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_ARMARCH5gnube::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_ARMARCH5gnube::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_ARMARCH5gnube {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnube
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return ARMARCH5
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return ARMARCH5gnube
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_ARMARCH5gnube
}
set tcInfo_ARMARCH6gnu(TOOL_FAMILY) gnu
set tcInfo_ARMARCH6gnu(CC) "ccarm"
set tcInfo_ARMARCH6gnu(CPP) "ccarm -E -P"
set tcInfo_ARMARCH6gnu(AS) "ccarm"
set tcInfo_ARMARCH6gnu(LD) "ldarm"
set tcInfo_ARMARCH6gnu(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EL"
set tcInfo_ARMARCH6gnu(NM) "nmarm -g"
set tcInfo_ARMARCH6gnu(SIZE) "sizearm"
set tcInfo_ARMARCH6gnu(AR) "ararm"
set tcInfo_ARMARCH6gnu(CFLAGS) {-g -t6 -ansi -fno-builtin -Wall -DARMEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH6gnu(CFLAGS_AS) {-g -t6 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH6gnu(LDFLAGS) "-X -EL -N"
set tcInfo_ARMARCH6gnu(LD_PARTIAL_FLAGS) "-X -EL -r"
set tcInfo_ARMARCH6gnu(HEX_FLAGS) ""
set tcInfo_ARMARCH6gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_ARMARCH6gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_ARMARCH6gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_ARMARCH6gnu(OPTION_LANG_C) -xc
set tcInfo_ARMARCH6gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_ARMARCH6gnu(OPTION_DEPEND) "-M -w"
set tcInfo_ARMARCH6gnu(CC_ARCH_SPEC) "-t6"
namespace eval ::tc_ARMARCH6gnu { }

set tc_ARMARCH6gnu::tcname(little_soft) gnu

namespace eval ::tc_ARMARCH6gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_ARMARCH6gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_ARMARCH6gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_ARMARCH6gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return ARMARCH6
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return ARMARCH6gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_ARMARCH6gnu
}
set tcInfo_ARMARCH6gnube(TOOL_FAMILY) gnu
set tcInfo_ARMARCH6gnube(CC) "ccarm"
set tcInfo_ARMARCH6gnube(CPP) "ccarm -E -P"
set tcInfo_ARMARCH6gnube(AS) "ccarm"
set tcInfo_ARMARCH6gnube(LD) "ldarm"
set tcInfo_ARMARCH6gnube(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EB"
set tcInfo_ARMARCH6gnube(NM) "nmarm -g"
set tcInfo_ARMARCH6gnube(SIZE) "sizearm"
set tcInfo_ARMARCH6gnube(AR) "ararm"
set tcInfo_ARMARCH6gnube(CFLAGS) {-g -t5be -Wa,-EB -ansi -fno-builtin -Wall -DARMEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH6gnube(CFLAGS_AS) {-g -t5be -Wa,-EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_ARMARCH6gnube(LDFLAGS) "-X -EB -N"
set tcInfo_ARMARCH6gnube(LD_PARTIAL_FLAGS) "-X -EB -r"
set tcInfo_ARMARCH6gnube(HEX_FLAGS) ""
set tcInfo_ARMARCH6gnube(OPTION_INCLUDE_DIR) -I
set tcInfo_ARMARCH6gnube(OPTION_DEFINE_MACRO) -D
set tcInfo_ARMARCH6gnube(OPTION_UNDEFINE_MACRO) -U
set tcInfo_ARMARCH6gnube(OPTION_LANG_C) -xc
set tcInfo_ARMARCH6gnube(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_ARMARCH6gnube(OPTION_DEPEND) "-M -w"
set tcInfo_ARMARCH6gnube(CC_ARCH_SPEC) "-t5be  -Wa,-EB"
namespace eval ::tc_ARMARCH6gnu { }

set tc_ARMARCH6gnu::tcname(big_soft) gnube

namespace eval ::tc_ARMARCH6gnube::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_ARMARCH6gnube::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_ARMARCH6gnube::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_ARMARCH6gnube {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnube
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return ARMARCH6
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return ARMARCH6gnube
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_ARMARCH6gnube
}
set tcInfo_CPU32gnu(TOOL_FAMILY) gnu
set tcInfo_CPU32gnu(CC) "cc68k"
set tcInfo_CPU32gnu(CPP) "cc68k -E -P"
set tcInfo_CPU32gnu(AS) "cc68k"
set tcInfo_CPU32gnu(LD) "ld68k"
set tcInfo_CPU32gnu(LD_PARTIAL) "cc68k -r -nostdlib -Wl,-X"
set tcInfo_CPU32gnu(NM) "nm68k -g"
set tcInfo_CPU32gnu(SIZE) "size68k"
set tcInfo_CPU32gnu(AR) "ar68k"
set tcInfo_CPU32gnu(CFLAGS) {-g -mnobitfield -ansi -fno-builtin -Wall -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_CPU32gnu(CFLAGS_AS) {-g -mnobitfield -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_CPU32gnu(LDFLAGS) "-X -N"
set tcInfo_CPU32gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_CPU32gnu(HEX_FLAGS) "--output-vector-sp=0x --output-vector-pc=0x"
set tcInfo_CPU32gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_CPU32gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_CPU32gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_CPU32gnu(OPTION_LANG_C) -xc
set tcInfo_CPU32gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_CPU32gnu(OPTION_DEPEND) "-M -w"
set tcInfo_CPU32gnu(CC_ARCH_SPEC) "-mnobitfield"
namespace eval ::tc_CPU32gnu { }

set tc_CPU32gnu::tcname(undef_undef) gnu

namespace eval ::tc_CPU32gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_CPU32gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_CPU32gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ld68k $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_CPU32gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return CPU32
    }

    proc archDir {} {
	return mc68k
    }

    proc name {} {
	return CPU32gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec cc68k -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_CPU32gnu
}
set tcInfo_FR500gnu(TOOL_FAMILY) gnu
set tcInfo_FR500gnu(CC) "ccfrv"
set tcInfo_FR500gnu(CPP) "ccfrv -E -P"
set tcInfo_FR500gnu(AS) "ccfrv"
set tcInfo_FR500gnu(LD) "ldfrv"
set tcInfo_FR500gnu(LD_PARTIAL) "ccfrv -r -nostdlib -Wl,-EB -Wl,-X -Wl,-n"
set tcInfo_FR500gnu(NM) "nmfrv -g"
set tcInfo_FR500gnu(SIZE) "sizefrv"
set tcInfo_FR500gnu(AR) "arfrv"
set tcInfo_FR500gnu(CFLAGS) {-g -mcpu=fr500 -G0 -mdword -fschedule-insns2 -fcommon -ansi -funroll-loops -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_FR500gnu(CFLAGS_AS) {-g -mcpu=fr500 -G0 -funroll-loops -xassembler-with-cpp}
set tcInfo_FR500gnu(LDFLAGS) "-EB -X -n"
set tcInfo_FR500gnu(LD_PARTIAL_FLAGS) "-EB -X -r -n"
set tcInfo_FR500gnu(HEX_FLAGS) ""
set tcInfo_FR500gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_FR500gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_FR500gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_FR500gnu(OPTION_LANG_C) -xc
set tcInfo_FR500gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_FR500gnu(OPTION_DEPEND) "-M -w"
set tcInfo_FR500gnu(CC_ARCH_SPEC) "-mcpu=fr500 -G0 -mdword -fschedule-insns2 -fcommon"
namespace eval ::tc_FR500gnu { }

set tc_FR500gnu::tcname(undef_undef) gnu

namespace eval ::tc_FR500gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_FR500gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_FR500gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldfrv $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_FR500gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return FR500
    }

    proc archDir {} {
	return frv
    }

    proc name {} {
	return FR500gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccfrv -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_FR500gnu
}
set tcInfo_I80386gnu(TOOL_FAMILY) gnu
set tcInfo_I80386gnu(CC) "ccpentium"
set tcInfo_I80386gnu(CPP) "ccpentium -E -P"
set tcInfo_I80386gnu(AS) "ccpentium"
set tcInfo_I80386gnu(LD) "ldpentium"
set tcInfo_I80386gnu(LD_PARTIAL) "ccpentium -r -nostdlib -Wl,-X"
set tcInfo_I80386gnu(NM) "nmpentium -g"
set tcInfo_I80386gnu(SIZE) "sizepentium"
set tcInfo_I80386gnu(AR) "arpentium"
set tcInfo_I80386gnu(CFLAGS) {-g -mcpu=i386 -march=i386 -ansi -nostdlib -fno-builtin -fno-defer-pop -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_I80386gnu(CFLAGS_AS) {-g -mcpu=i386 -march=i386 -ansi -nostdlib -fno-builtin -fno-defer-pop -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_I80386gnu(LDFLAGS) "-X -N"
set tcInfo_I80386gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_I80386gnu(HEX_FLAGS) ""
set tcInfo_I80386gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_I80386gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_I80386gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_I80386gnu(OPTION_LANG_C) -xc
set tcInfo_I80386gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_I80386gnu(OPTION_DEPEND) "-M -w"
set tcInfo_I80386gnu(CC_ARCH_SPEC) "-mcpu=i386 -march=i386"
namespace eval ::tc_I80386gnu { }

set tc_I80386gnu::tcname(undef_undef) gnu

namespace eval ::tc_I80386gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_I80386gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_I80386gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldpentium $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_I80386gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return I80386
    }

    proc archDir {} {
	return i86
    }

    proc name {} {
	return I80386gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccpentium -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_I80386gnu
}
set tcInfo_I80486gnu(TOOL_FAMILY) gnu
set tcInfo_I80486gnu(CC) "ccpentium"
set tcInfo_I80486gnu(CPP) "ccpentium -E -P"
set tcInfo_I80486gnu(AS) "ccpentium"
set tcInfo_I80486gnu(LD) "ldpentium"
set tcInfo_I80486gnu(LD_PARTIAL) "ccpentium -r -nostdlib -Wl,-X"
set tcInfo_I80486gnu(NM) "nmpentium -g"
set tcInfo_I80486gnu(SIZE) "sizepentium"
set tcInfo_I80486gnu(AR) "arpentium"
set tcInfo_I80486gnu(CFLAGS) {-g -mcpu=i486 -march=i486 -ansi -nostdlib -fno-builtin -fno-defer-pop -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_I80486gnu(CFLAGS_AS) {-g -mcpu=i486 -march=i486 -ansi -nostdlib -fno-builtin -fno-defer-pop -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_I80486gnu(LDFLAGS) "-X -N"
set tcInfo_I80486gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_I80486gnu(HEX_FLAGS) ""
set tcInfo_I80486gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_I80486gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_I80486gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_I80486gnu(OPTION_LANG_C) -xc
set tcInfo_I80486gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_I80486gnu(OPTION_DEPEND) "-M -w"
set tcInfo_I80486gnu(CC_ARCH_SPEC) "-mcpu=i486 -march=i486"
namespace eval ::tc_I80486gnu { }

set tc_I80486gnu::tcname(undef_undef) gnu

namespace eval ::tc_I80486gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_I80486gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_I80486gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldpentium $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_I80486gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return I80486
    }

    proc archDir {} {
	return i86
    }

    proc name {} {
	return I80486gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccpentium -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_I80486gnu
}
set tcInfo_MC68000gnu(TOOL_FAMILY) gnu
set tcInfo_MC68000gnu(CC) "cc68k"
set tcInfo_MC68000gnu(CPP) "cc68k -E -P"
set tcInfo_MC68000gnu(AS) "cc68k"
set tcInfo_MC68000gnu(LD) "ld68k"
set tcInfo_MC68000gnu(LD_PARTIAL) "cc68k -r -nostdlib -Wl,-X"
set tcInfo_MC68000gnu(NM) "nm68k -g"
set tcInfo_MC68000gnu(SIZE) "size68k"
set tcInfo_MC68000gnu(AR) "ar68k"
set tcInfo_MC68000gnu(CFLAGS) {-g -m68000 -ansi -fno-builtin -Wall -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68000gnu(CFLAGS_AS) {-g -m68000 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68000gnu(LDFLAGS) "-X -N"
set tcInfo_MC68000gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_MC68000gnu(HEX_FLAGS) "--output-vector-sp=0x --output-vector-pc=0x"
set tcInfo_MC68000gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MC68000gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MC68000gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MC68000gnu(OPTION_LANG_C) -xc
set tcInfo_MC68000gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MC68000gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MC68000gnu(CC_ARCH_SPEC) "-m68000"
namespace eval ::tc_MC68000gnu { }

set tc_MC68000gnu::tcname(undef_undef) gnu

namespace eval ::tc_MC68000gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MC68000gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MC68000gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ld68k $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MC68000gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MC68000
    }

    proc archDir {} {
	return mc68k
    }

    proc name {} {
	return MC68000gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec cc68k -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MC68000gnu
}
set tcInfo_MC68010gnu(TOOL_FAMILY) gnu
set tcInfo_MC68010gnu(CC) "cc68k"
set tcInfo_MC68010gnu(CPP) "cc68k -E -P"
set tcInfo_MC68010gnu(AS) "cc68k"
set tcInfo_MC68010gnu(LD) "ld68k"
set tcInfo_MC68010gnu(LD_PARTIAL) "cc68k -r -nostdlib -Wl,-X"
set tcInfo_MC68010gnu(NM) "nm68k -g"
set tcInfo_MC68010gnu(SIZE) "size68k"
set tcInfo_MC68010gnu(AR) "ar68k"
set tcInfo_MC68010gnu(CFLAGS) {-g -mc68000 -ansi -fno-builtin -Wall -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68010gnu(CFLAGS_AS) {-g -mc68000 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68010gnu(LDFLAGS) "-X -N"
set tcInfo_MC68010gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_MC68010gnu(HEX_FLAGS) "--output-vector-sp=0x --output-vector-pc=0x"
set tcInfo_MC68010gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MC68010gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MC68010gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MC68010gnu(OPTION_LANG_C) -xc
set tcInfo_MC68010gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MC68010gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MC68010gnu(CC_ARCH_SPEC) "-mc68000"
namespace eval ::tc_MC68010gnu { }

set tc_MC68010gnu::tcname(undef_undef) gnu

namespace eval ::tc_MC68010gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MC68010gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MC68010gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ld68k $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MC68010gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MC68010
    }

    proc archDir {} {
	return mc68k
    }

    proc name {} {
	return MC68010gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec cc68k -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MC68010gnu
}
set tcInfo_MC68020gnu(TOOL_FAMILY) gnu
set tcInfo_MC68020gnu(CC) "cc68k"
set tcInfo_MC68020gnu(CPP) "cc68k -E -P"
set tcInfo_MC68020gnu(AS) "cc68k"
set tcInfo_MC68020gnu(LD) "ld68k"
set tcInfo_MC68020gnu(LD_PARTIAL) "cc68k -r -nostdlib -Wl,-X"
set tcInfo_MC68020gnu(NM) "nm68k -g"
set tcInfo_MC68020gnu(SIZE) "size68k"
set tcInfo_MC68020gnu(AR) "ar68k"
set tcInfo_MC68020gnu(CFLAGS) {-g -m68030 -ansi -fno-builtin -Wall -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68020gnu(CFLAGS_AS) {-g -m68030 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68020gnu(LDFLAGS) "-X -N"
set tcInfo_MC68020gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_MC68020gnu(HEX_FLAGS) "--output-vector-sp=0x --output-vector-pc=0x"
set tcInfo_MC68020gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MC68020gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MC68020gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MC68020gnu(OPTION_LANG_C) -xc
set tcInfo_MC68020gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MC68020gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MC68020gnu(CC_ARCH_SPEC) "-m68030"
namespace eval ::tc_MC68020gnu { }

set tc_MC68020gnu::tcname(undef_undef) gnu

namespace eval ::tc_MC68020gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MC68020gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MC68020gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ld68k $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MC68020gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MC68020
    }

    proc archDir {} {
	return mc68k
    }

    proc name {} {
	return MC68020gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec cc68k -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MC68020gnu
}
set tcInfo_MC68040gnu(TOOL_FAMILY) gnu
set tcInfo_MC68040gnu(CC) "cc68k"
set tcInfo_MC68040gnu(CPP) "cc68k -E -P"
set tcInfo_MC68040gnu(AS) "cc68k"
set tcInfo_MC68040gnu(LD) "ld68k"
set tcInfo_MC68040gnu(LD_PARTIAL) "cc68k -r -nostdlib -Wl,-X"
set tcInfo_MC68040gnu(NM) "nm68k -g"
set tcInfo_MC68040gnu(SIZE) "size68k"
set tcInfo_MC68040gnu(AR) "ar68k"
set tcInfo_MC68040gnu(CFLAGS) {-g -m68040 -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68040gnu(CFLAGS_AS) {-g -m68040 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68040gnu(LDFLAGS) "-X -N"
set tcInfo_MC68040gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_MC68040gnu(HEX_FLAGS) "--output-vector-sp=0x --output-vector-pc=0x"
set tcInfo_MC68040gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MC68040gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MC68040gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MC68040gnu(OPTION_LANG_C) -xc
set tcInfo_MC68040gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MC68040gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MC68040gnu(CC_ARCH_SPEC) "-m68040"
namespace eval ::tc_MC68040gnu { }

set tc_MC68040gnu::tcname(undef_undef) gnu

namespace eval ::tc_MC68040gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MC68040gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MC68040gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ld68k $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MC68040gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MC68040
    }

    proc archDir {} {
	return mc68k
    }

    proc name {} {
	return MC68040gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec cc68k -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MC68040gnu
}
set tcInfo_MC68060gnu(TOOL_FAMILY) gnu
set tcInfo_MC68060gnu(CC) "cc68k"
set tcInfo_MC68060gnu(CPP) "cc68k -E -P"
set tcInfo_MC68060gnu(AS) "cc68k"
set tcInfo_MC68060gnu(LD) "ld68k"
set tcInfo_MC68060gnu(LD_PARTIAL) "cc68k -r -nostdlib -Wl,-X"
set tcInfo_MC68060gnu(NM) "nm68k -g"
set tcInfo_MC68060gnu(SIZE) "size68k"
set tcInfo_MC68060gnu(AR) "ar68k"
set tcInfo_MC68060gnu(CFLAGS) {-g -m68040 -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68060gnu(CFLAGS_AS) {-g -m68040 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68060gnu(LDFLAGS) "-X -N"
set tcInfo_MC68060gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_MC68060gnu(HEX_FLAGS) "--output-vector-sp=0x --output-vector-pc=0x"
set tcInfo_MC68060gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MC68060gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MC68060gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MC68060gnu(OPTION_LANG_C) -xc
set tcInfo_MC68060gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MC68060gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MC68060gnu(CC_ARCH_SPEC) "-m68040"
namespace eval ::tc_MC68060gnu { }

set tc_MC68060gnu::tcname(undef_undef) gnu

namespace eval ::tc_MC68060gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MC68060gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MC68060gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ld68k $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MC68060gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MC68060
    }

    proc archDir {} {
	return mc68k
    }

    proc name {} {
	return MC68060gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec cc68k -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MC68060gnu
}
set tcInfo_MC68LC040gnu(TOOL_FAMILY) gnu
set tcInfo_MC68LC040gnu(CC) "cc68k"
set tcInfo_MC68LC040gnu(CPP) "cc68k -E -P"
set tcInfo_MC68LC040gnu(AS) "cc68k"
set tcInfo_MC68LC040gnu(LD) "ld68k"
set tcInfo_MC68LC040gnu(LD_PARTIAL) "cc68k -r -nostdlib -Wl,-X"
set tcInfo_MC68LC040gnu(NM) "nm68k -g"
set tcInfo_MC68LC040gnu(SIZE) "size68k"
set tcInfo_MC68LC040gnu(AR) "ar68k"
set tcInfo_MC68LC040gnu(CFLAGS) {-g -m68040 -ansi -fno-builtin -Wall -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68LC040gnu(CFLAGS_AS) {-g -m68040 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MC68LC040gnu(LDFLAGS) "-X -N"
set tcInfo_MC68LC040gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_MC68LC040gnu(HEX_FLAGS) "--output-vector-sp=0x --output-vector-pc=0x"
set tcInfo_MC68LC040gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MC68LC040gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MC68LC040gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MC68LC040gnu(OPTION_LANG_C) -xc
set tcInfo_MC68LC040gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MC68LC040gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MC68LC040gnu(CC_ARCH_SPEC) "-m68040"
namespace eval ::tc_MC68LC040gnu { }

set tc_MC68LC040gnu::tcname(undef_undef) gnu

namespace eval ::tc_MC68LC040gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MC68LC040gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MC68LC040gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ld68k $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MC68LC040gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MC68LC040
    }

    proc archDir {} {
	return mc68k
    }

    proc name {} {
	return MC68LC040gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec cc68k -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MC68LC040gnu
}
set tcInfo_MCORE15gnu(TOOL_FAMILY) gnu
set tcInfo_MCORE15gnu(CC) "ccmcore"
set tcInfo_MCORE15gnu(CPP) "ccmcore -E -P"
set tcInfo_MCORE15gnu(AS) "ccmcore"
set tcInfo_MCORE15gnu(LD) "ldmcore"
set tcInfo_MCORE15gnu(LD_PARTIAL) "ccmcore -r -nostdlib -Wl,-X"
set tcInfo_MCORE15gnu(NM) "nmmcore -g"
set tcInfo_MCORE15gnu(SIZE) "sizemcore"
set tcInfo_MCORE15gnu(AR) "armcore"
set tcInfo_MCORE15gnu(CFLAGS) {-g -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MCORE15gnu(CFLAGS_AS) {-g -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MCORE15gnu(LDFLAGS) "-X -n"
set tcInfo_MCORE15gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_MCORE15gnu(HEX_FLAGS) ""
set tcInfo_MCORE15gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MCORE15gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MCORE15gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MCORE15gnu(OPTION_LANG_C) -xc
set tcInfo_MCORE15gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MCORE15gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MCORE15gnu(CC_ARCH_SPEC) ""
namespace eval ::tc_MCORE15gnu { }

set tc_MCORE15gnu::tcname(undef_undef) gnu

namespace eval ::tc_MCORE15gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MCORE15gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MCORE15gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmcore $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MCORE15gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MCORE15
    }

    proc archDir {} {
	return mcore
    }

    proc name {} {
	return MCORE15gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmcore -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MCORE15gnu
}
set tcInfo_MIPSI2gnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI2gnu(CC) "ccmips"
set tcInfo_MIPSI2gnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI2gnu(AS) "ccmips"
set tcInfo_MIPSI2gnu(LD) "ldmips"
set tcInfo_MIPSI2gnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI2gnu(NM) "nmmips -g"
set tcInfo_MIPSI2gnu(SIZE) "sizemips"
set tcInfo_MIPSI2gnu(AR) "armips"
set tcInfo_MIPSI2gnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips2 -mgp32 -EB -ansi -fno-builtin -Wall -DMIPSEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI2gnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips2 -mgp32 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEB}
set tcInfo_MIPSI2gnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI2gnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI2gnu(HEX_FLAGS) ""
set tcInfo_MIPSI2gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI2gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI2gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI2gnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI2gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI2gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI2gnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips2 -mgp32 -EB"
namespace eval ::tc_MIPSI2gnu { }

set tc_MIPSI2gnu::tcname(big_hard) gnu

namespace eval ::tc_MIPSI2gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI2gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI2gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI2gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI2gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI2gnu
}
set tcInfo_MIPSI2sfgnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI2sfgnu(CC) "ccmips"
set tcInfo_MIPSI2sfgnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI2sfgnu(AS) "ccmips"
set tcInfo_MIPSI2sfgnu(LD) "ldmips"
set tcInfo_MIPSI2sfgnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI2sfgnu(NM) "nmmips -g"
set tcInfo_MIPSI2sfgnu(SIZE) "sizemips"
set tcInfo_MIPSI2sfgnu(AR) "armips"
set tcInfo_MIPSI2sfgnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips2 -mgp32 -EB -ansi -fno-builtin -Wall -DMIPSEB -DSOFT_FLOAT -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI2sfgnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips2 -mgp32 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEB -DSOFT_FLOAT}
set tcInfo_MIPSI2sfgnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI2sfgnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI2sfgnu(HEX_FLAGS) ""
set tcInfo_MIPSI2sfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI2sfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI2sfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI2sfgnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI2sfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI2sfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI2sfgnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips2 -mgp32 -EB"
namespace eval ::tc_MIPSI2gnu { }

set tc_MIPSI2gnu::tcname(big_soft) sfgnu

namespace eval ::tc_MIPSI2sfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI2sfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI2sfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI2sfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI2sfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI2sfgnu
}
set tcInfo_MIPSI2sfgnule(TOOL_FAMILY) gnu
set tcInfo_MIPSI2sfgnule(CC) "ccmips"
set tcInfo_MIPSI2sfgnule(CPP) "ccmips -E -P"
set tcInfo_MIPSI2sfgnule(AS) "ccmips"
set tcInfo_MIPSI2sfgnule(LD) "ldmips"
set tcInfo_MIPSI2sfgnule(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EL -Wl,-X"
set tcInfo_MIPSI2sfgnule(NM) "nmmips -g"
set tcInfo_MIPSI2sfgnule(SIZE) "sizemips"
set tcInfo_MIPSI2sfgnule(AR) "armips"
set tcInfo_MIPSI2sfgnule(CFLAGS) {-g -G 0 -mno-branch-likely -mips2 -mgp32 -EL -ansi -fno-builtin -Wall -DMIPSEL -DSOFT_FLOAT -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI2sfgnule(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips2 -mgp32 -EL -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEL -DSOFT_FLOAT}
set tcInfo_MIPSI2sfgnule(LDFLAGS) "-EL -X -N"
set tcInfo_MIPSI2sfgnule(LD_PARTIAL_FLAGS) "-EL -X -r"
set tcInfo_MIPSI2sfgnule(HEX_FLAGS) ""
set tcInfo_MIPSI2sfgnule(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI2sfgnule(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI2sfgnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI2sfgnule(OPTION_LANG_C) -xc
set tcInfo_MIPSI2sfgnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI2sfgnule(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI2sfgnule(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips2 -mgp32 -EL"
namespace eval ::tc_MIPSI2gnu { }

set tc_MIPSI2gnu::tcname(little_soft) sfgnule

namespace eval ::tc_MIPSI2sfgnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI2sfgnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI2sfgnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI2sfgnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI2sfgnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI2sfgnule
}
set tcInfo_MIPSI32R2gnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI32R2gnu(CC) "ccmips"
set tcInfo_MIPSI32R2gnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI32R2gnu(AS) "ccmips"
set tcInfo_MIPSI32R2gnu(LD) "ldmips"
set tcInfo_MIPSI32R2gnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI32R2gnu(NM) "nmmips -g"
set tcInfo_MIPSI32R2gnu(SIZE) "sizemips"
set tcInfo_MIPSI32R2gnu(AR) "armips"
set tcInfo_MIPSI32R2gnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips32r2 -mgp32 -EB -ansi -fno-builtin -Wall -DMIPSEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI32R2gnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips32r2 -mgp32 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEB}
set tcInfo_MIPSI32R2gnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI32R2gnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI32R2gnu(HEX_FLAGS) ""
set tcInfo_MIPSI32R2gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI32R2gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI32R2gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI32R2gnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI32R2gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI32R2gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI32R2gnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips32r2 -mgp32 -EB"
namespace eval ::tc_MIPSI32R2gnu { }

set tc_MIPSI32R2gnu::tcname(big_hard) gnu

namespace eval ::tc_MIPSI32R2gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI32R2gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI32R2gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI32R2gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI32R2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI32R2gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI32R2gnu
}
set tcInfo_MIPSI32R2gnule(TOOL_FAMILY) gnu
set tcInfo_MIPSI32R2gnule(CC) "ccmips"
set tcInfo_MIPSI32R2gnule(CPP) "ccmips -E -P"
set tcInfo_MIPSI32R2gnule(AS) "ccmips"
set tcInfo_MIPSI32R2gnule(LD) "ldmips"
set tcInfo_MIPSI32R2gnule(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EL -Wl,-X"
set tcInfo_MIPSI32R2gnule(NM) "nmmips -g"
set tcInfo_MIPSI32R2gnule(SIZE) "sizemips"
set tcInfo_MIPSI32R2gnule(AR) "armips"
set tcInfo_MIPSI32R2gnule(CFLAGS) {-g -G 0 -mno-branch-likely -mips32r2 -mgp32 -EL -ansi -fno-builtin -Wall -DMIPSEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI32R2gnule(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips32r2 -mgp32 -EL -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEL}
set tcInfo_MIPSI32R2gnule(LDFLAGS) "-EL -X -N"
set tcInfo_MIPSI32R2gnule(LD_PARTIAL_FLAGS) "-EL -X -r"
set tcInfo_MIPSI32R2gnule(HEX_FLAGS) ""
set tcInfo_MIPSI32R2gnule(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI32R2gnule(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI32R2gnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI32R2gnule(OPTION_LANG_C) -xc
set tcInfo_MIPSI32R2gnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI32R2gnule(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI32R2gnule(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips32r2 -mgp32 -EL"
namespace eval ::tc_MIPSI32R2gnu { }

set tc_MIPSI32R2gnu::tcname(little_hard) gnule

namespace eval ::tc_MIPSI32R2gnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI32R2gnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI32R2gnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI32R2gnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI32R2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI32R2gnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI32R2gnule
}
set tcInfo_MIPSI32R2sfgnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI32R2sfgnu(CC) "ccmips"
set tcInfo_MIPSI32R2sfgnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI32R2sfgnu(AS) "ccmips"
set tcInfo_MIPSI32R2sfgnu(LD) "ldmips"
set tcInfo_MIPSI32R2sfgnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI32R2sfgnu(NM) "nmmips -g"
set tcInfo_MIPSI32R2sfgnu(SIZE) "sizemips"
set tcInfo_MIPSI32R2sfgnu(AR) "armips"
set tcInfo_MIPSI32R2sfgnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips32r2 -mgp32 -EB -ansi -fno-builtin -Wall -DMIPSEB -DSOFT_FLOAT -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI32R2sfgnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips32r2 -mgp32 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEB -DSOFT_FLOAT}
set tcInfo_MIPSI32R2sfgnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI32R2sfgnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI32R2sfgnu(HEX_FLAGS) ""
set tcInfo_MIPSI32R2sfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI32R2sfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI32R2sfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI32R2sfgnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI32R2sfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI32R2sfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI32R2sfgnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips32r2 -mgp32 -EB"
namespace eval ::tc_MIPSI32R2gnu { }

set tc_MIPSI32R2gnu::tcname(big_soft) sfgnu

namespace eval ::tc_MIPSI32R2sfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI32R2sfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI32R2sfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI32R2sfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI32R2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI32R2sfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI32R2sfgnu
}
set tcInfo_MIPSI32R2sfgnule(TOOL_FAMILY) gnu
set tcInfo_MIPSI32R2sfgnule(CC) "ccmips"
set tcInfo_MIPSI32R2sfgnule(CPP) "ccmips -E -P"
set tcInfo_MIPSI32R2sfgnule(AS) "ccmips"
set tcInfo_MIPSI32R2sfgnule(LD) "ldmips"
set tcInfo_MIPSI32R2sfgnule(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EL -Wl,-X"
set tcInfo_MIPSI32R2sfgnule(NM) "nmmips -g"
set tcInfo_MIPSI32R2sfgnule(SIZE) "sizemips"
set tcInfo_MIPSI32R2sfgnule(AR) "armips"
set tcInfo_MIPSI32R2sfgnule(CFLAGS) {-g -G 0 -mno-branch-likely -mips32r2 -mgp32 -EL -ansi -fno-builtin -Wall -DMIPSEL -DSOFT_FLOAT -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI32R2sfgnule(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips32r2 -mgp32 -EL -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEL -DSOFT_FLOAT}
set tcInfo_MIPSI32R2sfgnule(LDFLAGS) "-EL -X -N"
set tcInfo_MIPSI32R2sfgnule(LD_PARTIAL_FLAGS) "-EL -X -r"
set tcInfo_MIPSI32R2sfgnule(HEX_FLAGS) ""
set tcInfo_MIPSI32R2sfgnule(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI32R2sfgnule(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI32R2sfgnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI32R2sfgnule(OPTION_LANG_C) -xc
set tcInfo_MIPSI32R2sfgnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI32R2sfgnule(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI32R2sfgnule(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips32r2 -mgp32 -EL"
namespace eval ::tc_MIPSI32R2gnu { }

set tc_MIPSI32R2gnu::tcname(little_soft) sfgnule

namespace eval ::tc_MIPSI32R2sfgnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI32R2sfgnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI32R2sfgnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI32R2sfgnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI32R2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI32R2sfgnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI32R2sfgnule
}
set tcInfo_MIPSI32gnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI32gnu(CC) "ccmips"
set tcInfo_MIPSI32gnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI32gnu(AS) "ccmips"
set tcInfo_MIPSI32gnu(LD) "ldmips"
set tcInfo_MIPSI32gnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI32gnu(NM) "nmmips -g"
set tcInfo_MIPSI32gnu(SIZE) "sizemips"
set tcInfo_MIPSI32gnu(AR) "armips"
set tcInfo_MIPSI32gnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips32 -mgp32 -EB -ansi -fno-builtin -Wall -DMIPSEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI32gnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips32 -mgp32 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEB}
set tcInfo_MIPSI32gnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI32gnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI32gnu(HEX_FLAGS) ""
set tcInfo_MIPSI32gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI32gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI32gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI32gnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI32gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI32gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI32gnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips32 -mgp32 -EB"
namespace eval ::tc_MIPSI32gnu { }

set tc_MIPSI32gnu::tcname(big_hard) gnu

namespace eval ::tc_MIPSI32gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI32gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI32gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI32gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI32
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI32gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI32gnu
}
set tcInfo_MIPSI32gnule(TOOL_FAMILY) gnu
set tcInfo_MIPSI32gnule(CC) "ccmips"
set tcInfo_MIPSI32gnule(CPP) "ccmips -E -P"
set tcInfo_MIPSI32gnule(AS) "ccmips"
set tcInfo_MIPSI32gnule(LD) "ldmips"
set tcInfo_MIPSI32gnule(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EL -Wl,-X"
set tcInfo_MIPSI32gnule(NM) "nmmips -g"
set tcInfo_MIPSI32gnule(SIZE) "sizemips"
set tcInfo_MIPSI32gnule(AR) "armips"
set tcInfo_MIPSI32gnule(CFLAGS) {-g -G 0 -mno-branch-likely -mips32 -mgp32 -EL -ansi -fno-builtin -Wall -DMIPSEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI32gnule(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips32 -mgp32 -EL -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEL}
set tcInfo_MIPSI32gnule(LDFLAGS) "-EL -X -N"
set tcInfo_MIPSI32gnule(LD_PARTIAL_FLAGS) "-EL -X -r"
set tcInfo_MIPSI32gnule(HEX_FLAGS) ""
set tcInfo_MIPSI32gnule(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI32gnule(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI32gnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI32gnule(OPTION_LANG_C) -xc
set tcInfo_MIPSI32gnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI32gnule(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI32gnule(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips32 -mgp32 -EL"
namespace eval ::tc_MIPSI32gnu { }

set tc_MIPSI32gnu::tcname(little_hard) gnule

namespace eval ::tc_MIPSI32gnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI32gnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI32gnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI32gnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI32
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI32gnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI32gnule
}
set tcInfo_MIPSI32sfgnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI32sfgnu(CC) "ccmips"
set tcInfo_MIPSI32sfgnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI32sfgnu(AS) "ccmips"
set tcInfo_MIPSI32sfgnu(LD) "ldmips"
set tcInfo_MIPSI32sfgnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI32sfgnu(NM) "nmmips -g"
set tcInfo_MIPSI32sfgnu(SIZE) "sizemips"
set tcInfo_MIPSI32sfgnu(AR) "armips"
set tcInfo_MIPSI32sfgnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips32 -mgp32 -EB -ansi -fno-builtin -Wall -DMIPSEB -DSOFT_FLOAT -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI32sfgnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips32 -mgp32 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEB -DSOFT_FLOAT}
set tcInfo_MIPSI32sfgnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI32sfgnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI32sfgnu(HEX_FLAGS) ""
set tcInfo_MIPSI32sfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI32sfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI32sfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI32sfgnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI32sfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI32sfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI32sfgnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips32 -mgp32 -EB"
namespace eval ::tc_MIPSI32gnu { }

set tc_MIPSI32gnu::tcname(big_soft) sfgnu

namespace eval ::tc_MIPSI32sfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI32sfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI32sfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI32sfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI32
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI32sfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI32sfgnu
}
set tcInfo_MIPSI32sfgnule(TOOL_FAMILY) gnu
set tcInfo_MIPSI32sfgnule(CC) "ccmips"
set tcInfo_MIPSI32sfgnule(CPP) "ccmips -E -P"
set tcInfo_MIPSI32sfgnule(AS) "ccmips"
set tcInfo_MIPSI32sfgnule(LD) "ldmips"
set tcInfo_MIPSI32sfgnule(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EL -Wl,-X"
set tcInfo_MIPSI32sfgnule(NM) "nmmips -g"
set tcInfo_MIPSI32sfgnule(SIZE) "sizemips"
set tcInfo_MIPSI32sfgnule(AR) "armips"
set tcInfo_MIPSI32sfgnule(CFLAGS) {-g -G 0 -mno-branch-likely -mips32 -mgp32 -EL -ansi -fno-builtin -Wall -DMIPSEL -DSOFT_FLOAT -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI32sfgnule(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips32 -mgp32 -EL -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -DMIPSEL -DSOFT_FLOAT}
set tcInfo_MIPSI32sfgnule(LDFLAGS) "-EL -X -N"
set tcInfo_MIPSI32sfgnule(LD_PARTIAL_FLAGS) "-EL -X -r"
set tcInfo_MIPSI32sfgnule(HEX_FLAGS) ""
set tcInfo_MIPSI32sfgnule(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI32sfgnule(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI32sfgnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI32sfgnule(OPTION_LANG_C) -xc
set tcInfo_MIPSI32sfgnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI32sfgnule(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI32sfgnule(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips32 -mgp32 -EL"
namespace eval ::tc_MIPSI32gnu { }

set tc_MIPSI32gnu::tcname(little_soft) sfgnule

namespace eval ::tc_MIPSI32sfgnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI32sfgnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI32sfgnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI32sfgnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI32
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI32sfgnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI32sfgnule
}
set tcInfo_MIPSI3gnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI3gnu(CC) "ccmips"
set tcInfo_MIPSI3gnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI3gnu(AS) "ccmips"
set tcInfo_MIPSI3gnu(LD) "ldmips"
set tcInfo_MIPSI3gnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI3gnu(NM) "nmmips -g"
set tcInfo_MIPSI3gnu(SIZE) "sizemips"
set tcInfo_MIPSI3gnu(AR) "armips"
set tcInfo_MIPSI3gnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips3 -mabi=n32 -mgp64 -EB -ansi -fno-builtin -Wall -D_WRS_MIPS_N32_ABI -DMIPSEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI3gnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips3 -mabi=n32 -mgp64 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -D_WRS_MIPS_N32_ABI -DMIPSEB}
set tcInfo_MIPSI3gnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI3gnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI3gnu(HEX_FLAGS) ""
set tcInfo_MIPSI3gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI3gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI3gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI3gnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI3gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI3gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI3gnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips3 -mabi=n32 -mgp64 -EB"
namespace eval ::tc_MIPSI3gnu { }

set tc_MIPSI3gnu::tcname(big_hard) gnu

namespace eval ::tc_MIPSI3gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI3gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI3gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI3gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI3
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI3gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI3gnu
}
set tcInfo_MIPSI3gnule(TOOL_FAMILY) gnu
set tcInfo_MIPSI3gnule(CC) "ccmips"
set tcInfo_MIPSI3gnule(CPP) "ccmips -E -P"
set tcInfo_MIPSI3gnule(AS) "ccmips"
set tcInfo_MIPSI3gnule(LD) "ldmips"
set tcInfo_MIPSI3gnule(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EL -Wl,-X"
set tcInfo_MIPSI3gnule(NM) "nmmips -g"
set tcInfo_MIPSI3gnule(SIZE) "sizemips"
set tcInfo_MIPSI3gnule(AR) "armips"
set tcInfo_MIPSI3gnule(CFLAGS) {-g -G 0 -mno-branch-likely -mips3 -mabi=n32 -mgp64 -EL -ansi -fno-builtin -Wall -D_WRS_MIPS_N32_ABI -DMIPSEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI3gnule(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips3 -mabi=n32 -mgp64 -EL -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -D_WRS_MIPS_N32_ABI -DMIPSEL}
set tcInfo_MIPSI3gnule(LDFLAGS) "-EL -X -N"
set tcInfo_MIPSI3gnule(LD_PARTIAL_FLAGS) "-EL -X -r"
set tcInfo_MIPSI3gnule(HEX_FLAGS) ""
set tcInfo_MIPSI3gnule(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI3gnule(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI3gnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI3gnule(OPTION_LANG_C) -xc
set tcInfo_MIPSI3gnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI3gnule(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI3gnule(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips3 -mabi=n32 -mgp64 -EL"
namespace eval ::tc_MIPSI3gnu { }

set tc_MIPSI3gnu::tcname(little_hard) gnule

namespace eval ::tc_MIPSI3gnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI3gnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI3gnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI3gnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI3
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI3gnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI3gnule
}
set tcInfo_MIPSI64R2gnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI64R2gnu(CC) "ccmips"
set tcInfo_MIPSI64R2gnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI64R2gnu(AS) "ccmips"
set tcInfo_MIPSI64R2gnu(LD) "ldmips"
set tcInfo_MIPSI64R2gnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI64R2gnu(NM) "nmmips -g"
set tcInfo_MIPSI64R2gnu(SIZE) "sizemips"
set tcInfo_MIPSI64R2gnu(AR) "armips"
set tcInfo_MIPSI64R2gnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EB -ansi -fno-builtin -Wall -D_WRS_MIPS_N32_ABI -DMIPSEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI64R2gnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -D_WRS_MIPS_N32_ABI -DMIPSEB}
set tcInfo_MIPSI64R2gnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI64R2gnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI64R2gnu(HEX_FLAGS) ""
set tcInfo_MIPSI64R2gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI64R2gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI64R2gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI64R2gnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI64R2gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI64R2gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI64R2gnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EB"
namespace eval ::tc_MIPSI64R2gnu { }

set tc_MIPSI64R2gnu::tcname(big_hard) gnu

namespace eval ::tc_MIPSI64R2gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI64R2gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI64R2gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI64R2gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI64R2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI64R2gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI64R2gnu
}
set tcInfo_MIPSI64R2gnule(TOOL_FAMILY) gnu
set tcInfo_MIPSI64R2gnule(CC) "ccmips"
set tcInfo_MIPSI64R2gnule(CPP) "ccmips -E -P"
set tcInfo_MIPSI64R2gnule(AS) "ccmips"
set tcInfo_MIPSI64R2gnule(LD) "ldmips"
set tcInfo_MIPSI64R2gnule(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EL -Wl,-X"
set tcInfo_MIPSI64R2gnule(NM) "nmmips -g"
set tcInfo_MIPSI64R2gnule(SIZE) "sizemips"
set tcInfo_MIPSI64R2gnule(AR) "armips"
set tcInfo_MIPSI64R2gnule(CFLAGS) {-g -G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EL -ansi -fno-builtin -Wall -D_WRS_MIPS_N32_ABI -DMIPSEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI64R2gnule(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EL -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -D_WRS_MIPS_N32_ABI -DMIPSEL}
set tcInfo_MIPSI64R2gnule(LDFLAGS) "-EL -X -N"
set tcInfo_MIPSI64R2gnule(LD_PARTIAL_FLAGS) "-EL -X -r"
set tcInfo_MIPSI64R2gnule(HEX_FLAGS) ""
set tcInfo_MIPSI64R2gnule(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI64R2gnule(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI64R2gnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI64R2gnule(OPTION_LANG_C) -xc
set tcInfo_MIPSI64R2gnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI64R2gnule(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI64R2gnule(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EL"
namespace eval ::tc_MIPSI64R2gnu { }

set tc_MIPSI64R2gnu::tcname(little_hard) gnule

namespace eval ::tc_MIPSI64R2gnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI64R2gnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI64R2gnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI64R2gnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI64R2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI64R2gnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI64R2gnule
}
set tcInfo_MIPSI64R2sfgnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI64R2sfgnu(CC) "ccmips"
set tcInfo_MIPSI64R2sfgnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI64R2sfgnu(AS) "ccmips"
set tcInfo_MIPSI64R2sfgnu(LD) "ldmips"
set tcInfo_MIPSI64R2sfgnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI64R2sfgnu(NM) "nmmips -g"
set tcInfo_MIPSI64R2sfgnu(SIZE) "sizemips"
set tcInfo_MIPSI64R2sfgnu(AR) "armips"
set tcInfo_MIPSI64R2sfgnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EB -ansi -fno-builtin -Wall -D_WRS_MIPS_N32_ABI -DMIPSEB -DSOFT_FLOAT -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI64R2sfgnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -D_WRS_MIPS_N32_ABI -DMIPSEB -DSOFT_FLOAT}
set tcInfo_MIPSI64R2sfgnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI64R2sfgnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI64R2sfgnu(HEX_FLAGS) ""
set tcInfo_MIPSI64R2sfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI64R2sfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI64R2sfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI64R2sfgnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI64R2sfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI64R2sfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI64R2sfgnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EB"
namespace eval ::tc_MIPSI64R2gnu { }

set tc_MIPSI64R2gnu::tcname(big_soft) sfgnu

namespace eval ::tc_MIPSI64R2sfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI64R2sfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI64R2sfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI64R2sfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI64R2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI64R2sfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI64R2sfgnu
}
set tcInfo_MIPSI64R2sfgnule(TOOL_FAMILY) gnu
set tcInfo_MIPSI64R2sfgnule(CC) "ccmips"
set tcInfo_MIPSI64R2sfgnule(CPP) "ccmips -E -P"
set tcInfo_MIPSI64R2sfgnule(AS) "ccmips"
set tcInfo_MIPSI64R2sfgnule(LD) "ldmips"
set tcInfo_MIPSI64R2sfgnule(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EL -Wl,-X"
set tcInfo_MIPSI64R2sfgnule(NM) "nmmips -g"
set tcInfo_MIPSI64R2sfgnule(SIZE) "sizemips"
set tcInfo_MIPSI64R2sfgnule(AR) "armips"
set tcInfo_MIPSI64R2sfgnule(CFLAGS) {-g -G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EL -ansi -fno-builtin -Wall -D_WRS_MIPS_N32_ABI -DMIPSEL -DSOFT_FLOAT -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI64R2sfgnule(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EL -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -D_WRS_MIPS_N32_ABI -DMIPSEL -DSOFT_FLOAT}
set tcInfo_MIPSI64R2sfgnule(LDFLAGS) "-EL -X -N"
set tcInfo_MIPSI64R2sfgnule(LD_PARTIAL_FLAGS) "-EL -X -r"
set tcInfo_MIPSI64R2sfgnule(HEX_FLAGS) ""
set tcInfo_MIPSI64R2sfgnule(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI64R2sfgnule(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI64R2sfgnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI64R2sfgnule(OPTION_LANG_C) -xc
set tcInfo_MIPSI64R2sfgnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI64R2sfgnule(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI64R2sfgnule(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips64 -Wa,-mips64r2 -mabi=n32 -mgp64 -EL"
namespace eval ::tc_MIPSI64R2gnu { }

set tc_MIPSI64R2gnu::tcname(little_soft) sfgnule

namespace eval ::tc_MIPSI64R2sfgnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI64R2sfgnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI64R2sfgnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI64R2sfgnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI64R2
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI64R2sfgnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI64R2sfgnule
}
set tcInfo_MIPSI64gnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI64gnu(CC) "ccmips"
set tcInfo_MIPSI64gnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI64gnu(AS) "ccmips"
set tcInfo_MIPSI64gnu(LD) "ldmips"
set tcInfo_MIPSI64gnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI64gnu(NM) "nmmips -g"
set tcInfo_MIPSI64gnu(SIZE) "sizemips"
set tcInfo_MIPSI64gnu(AR) "armips"
set tcInfo_MIPSI64gnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EB -ansi -fno-builtin -Wall -D_WRS_MIPS_N32_ABI -DMIPSEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI64gnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -D_WRS_MIPS_N32_ABI -DMIPSEB}
set tcInfo_MIPSI64gnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI64gnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI64gnu(HEX_FLAGS) ""
set tcInfo_MIPSI64gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI64gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI64gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI64gnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI64gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI64gnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI64gnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EB"
namespace eval ::tc_MIPSI64gnu { }

set tc_MIPSI64gnu::tcname(big_hard) gnu

namespace eval ::tc_MIPSI64gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI64gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI64gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI64gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI64
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI64gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI64gnu
}
set tcInfo_MIPSI64gnule(TOOL_FAMILY) gnu
set tcInfo_MIPSI64gnule(CC) "ccmips"
set tcInfo_MIPSI64gnule(CPP) "ccmips -E -P"
set tcInfo_MIPSI64gnule(AS) "ccmips"
set tcInfo_MIPSI64gnule(LD) "ldmips"
set tcInfo_MIPSI64gnule(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EL -Wl,-X"
set tcInfo_MIPSI64gnule(NM) "nmmips -g"
set tcInfo_MIPSI64gnule(SIZE) "sizemips"
set tcInfo_MIPSI64gnule(AR) "armips"
set tcInfo_MIPSI64gnule(CFLAGS) {-g -G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EL -ansi -fno-builtin -Wall -D_WRS_MIPS_N32_ABI -DMIPSEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI64gnule(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EL -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -D_WRS_MIPS_N32_ABI -DMIPSEL}
set tcInfo_MIPSI64gnule(LDFLAGS) "-EL -X -N"
set tcInfo_MIPSI64gnule(LD_PARTIAL_FLAGS) "-EL -X -r"
set tcInfo_MIPSI64gnule(HEX_FLAGS) ""
set tcInfo_MIPSI64gnule(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI64gnule(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI64gnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI64gnule(OPTION_LANG_C) -xc
set tcInfo_MIPSI64gnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI64gnule(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI64gnule(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EL"
namespace eval ::tc_MIPSI64gnu { }

set tc_MIPSI64gnu::tcname(little_hard) gnule

namespace eval ::tc_MIPSI64gnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI64gnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI64gnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI64gnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI64
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI64gnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI64gnule
}
set tcInfo_MIPSI64sfgnu(TOOL_FAMILY) gnu
set tcInfo_MIPSI64sfgnu(CC) "ccmips"
set tcInfo_MIPSI64sfgnu(CPP) "ccmips -E -P"
set tcInfo_MIPSI64sfgnu(AS) "ccmips"
set tcInfo_MIPSI64sfgnu(LD) "ldmips"
set tcInfo_MIPSI64sfgnu(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EB -Wl,-X"
set tcInfo_MIPSI64sfgnu(NM) "nmmips -g"
set tcInfo_MIPSI64sfgnu(SIZE) "sizemips"
set tcInfo_MIPSI64sfgnu(AR) "armips"
set tcInfo_MIPSI64sfgnu(CFLAGS) {-g -G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EB -ansi -fno-builtin -Wall -D_WRS_MIPS_N32_ABI -DMIPSEB -DSOFT_FLOAT -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI64sfgnu(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -D_WRS_MIPS_N32_ABI -DMIPSEB -DSOFT_FLOAT}
set tcInfo_MIPSI64sfgnu(LDFLAGS) "-EB -X -N"
set tcInfo_MIPSI64sfgnu(LD_PARTIAL_FLAGS) "-EB -X -r"
set tcInfo_MIPSI64sfgnu(HEX_FLAGS) ""
set tcInfo_MIPSI64sfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI64sfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI64sfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI64sfgnu(OPTION_LANG_C) -xc
set tcInfo_MIPSI64sfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI64sfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI64sfgnu(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EB"
namespace eval ::tc_MIPSI64gnu { }

set tc_MIPSI64gnu::tcname(big_soft) sfgnu

namespace eval ::tc_MIPSI64sfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI64sfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI64sfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI64sfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI64
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI64sfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI64sfgnu
}
set tcInfo_MIPSI64sfgnule(TOOL_FAMILY) gnu
set tcInfo_MIPSI64sfgnule(CC) "ccmips"
set tcInfo_MIPSI64sfgnule(CPP) "ccmips -E -P"
set tcInfo_MIPSI64sfgnule(AS) "ccmips"
set tcInfo_MIPSI64sfgnule(LD) "ldmips"
set tcInfo_MIPSI64sfgnule(LD_PARTIAL) "ccmips -r -nostdlib -Wl,-EL -Wl,-X"
set tcInfo_MIPSI64sfgnule(NM) "nmmips -g"
set tcInfo_MIPSI64sfgnule(SIZE) "sizemips"
set tcInfo_MIPSI64sfgnule(AR) "armips"
set tcInfo_MIPSI64sfgnule(CFLAGS) {-g -G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EL -ansi -fno-builtin -Wall -D_WRS_MIPS_N32_ABI -DMIPSEL -DSOFT_FLOAT -msoft-float -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_MIPSI64sfgnule(CFLAGS_AS) {-g -G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EL -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\" -D_WRS_MIPS_N32_ABI -DMIPSEL -DSOFT_FLOAT}
set tcInfo_MIPSI64sfgnule(LDFLAGS) "-EL -X -N"
set tcInfo_MIPSI64sfgnule(LD_PARTIAL_FLAGS) "-EL -X -r"
set tcInfo_MIPSI64sfgnule(HEX_FLAGS) ""
set tcInfo_MIPSI64sfgnule(OPTION_INCLUDE_DIR) -I
set tcInfo_MIPSI64sfgnule(OPTION_DEFINE_MACRO) -D
set tcInfo_MIPSI64sfgnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_MIPSI64sfgnule(OPTION_LANG_C) -xc
set tcInfo_MIPSI64sfgnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_MIPSI64sfgnule(OPTION_DEPEND) "-M -w"
set tcInfo_MIPSI64sfgnule(CC_ARCH_SPEC) "-G 0 -mno-branch-likely -mips64 -mabi=n32 -mgp64 -EL"
namespace eval ::tc_MIPSI64gnu { }

set tc_MIPSI64gnu::tcname(little_soft) sfgnule

namespace eval ::tc_MIPSI64sfgnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_MIPSI64sfgnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_MIPSI64sfgnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldmips $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_MIPSI64sfgnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return MIPSI64
    }

    proc archDir {} {
	return mips
    }

    proc name {} {
	return MIPSI64sfgnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccmips -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_MIPSI64sfgnule
}
set tcInfo_PENTIUM2gnu(TOOL_FAMILY) gnu
set tcInfo_PENTIUM2gnu(CC) "ccpentium"
set tcInfo_PENTIUM2gnu(CPP) "ccpentium -E -P"
set tcInfo_PENTIUM2gnu(AS) "ccpentium"
set tcInfo_PENTIUM2gnu(LD) "ldpentium"
set tcInfo_PENTIUM2gnu(LD_PARTIAL) "ccpentium -r -nostdlib -Wl,-X"
set tcInfo_PENTIUM2gnu(NM) "nmpentium -g"
set tcInfo_PENTIUM2gnu(SIZE) "sizepentium"
set tcInfo_PENTIUM2gnu(AR) "arpentium"
set tcInfo_PENTIUM2gnu(CFLAGS) {-g -mtune=pentiumpro -march=pentiumpro -nostdlib -fno-builtin -fno-defer-pop -ansi -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PENTIUM2gnu(CFLAGS_AS) {-g -mtune=pentiumpro -march=pentiumpro -nostdlib -fno-builtin -fno-defer-pop -ansi -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PENTIUM2gnu(LDFLAGS) "-X -N"
set tcInfo_PENTIUM2gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PENTIUM2gnu(HEX_FLAGS) ""
set tcInfo_PENTIUM2gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PENTIUM2gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PENTIUM2gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PENTIUM2gnu(OPTION_LANG_C) -xc
set tcInfo_PENTIUM2gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PENTIUM2gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PENTIUM2gnu(CC_ARCH_SPEC) "-mtune=pentiumpro -march=pentiumpro -nostdlib -fno-builtin -fno-defer-pop"
namespace eval ::tc_PENTIUM2gnu { }

set tc_PENTIUM2gnu::tcname(undef_undef) gnu

namespace eval ::tc_PENTIUM2gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PENTIUM2gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PENTIUM2gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldpentium $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PENTIUM2gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PENTIUM2
    }

    proc archDir {} {
	return i86
    }

    proc name {} {
	return PENTIUM2gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccpentium -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PENTIUM2gnu
}
set tcInfo_PENTIUM3gnu(TOOL_FAMILY) gnu
set tcInfo_PENTIUM3gnu(CC) "ccpentium"
set tcInfo_PENTIUM3gnu(CPP) "ccpentium -E -P"
set tcInfo_PENTIUM3gnu(AS) "ccpentium"
set tcInfo_PENTIUM3gnu(LD) "ldpentium"
set tcInfo_PENTIUM3gnu(LD_PARTIAL) "ccpentium -r -nostdlib -Wl,-X"
set tcInfo_PENTIUM3gnu(NM) "nmpentium -g"
set tcInfo_PENTIUM3gnu(SIZE) "sizepentium"
set tcInfo_PENTIUM3gnu(AR) "arpentium"
set tcInfo_PENTIUM3gnu(CFLAGS) {-g -mtune=pentium3 -march=pentium3 -nostdlib -fno-builtin -fno-defer-pop -ansi -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PENTIUM3gnu(CFLAGS_AS) {-g -mtune=pentium3 -march=pentium3 -nostdlib -fno-builtin -fno-defer-pop -ansi -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PENTIUM3gnu(LDFLAGS) "-X -N"
set tcInfo_PENTIUM3gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PENTIUM3gnu(HEX_FLAGS) ""
set tcInfo_PENTIUM3gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PENTIUM3gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PENTIUM3gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PENTIUM3gnu(OPTION_LANG_C) -xc
set tcInfo_PENTIUM3gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PENTIUM3gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PENTIUM3gnu(CC_ARCH_SPEC) "-mtune=pentium3 -march=pentium3 -nostdlib -fno-builtin -fno-defer-pop"
namespace eval ::tc_PENTIUM3gnu { }

set tc_PENTIUM3gnu::tcname(undef_undef) gnu

namespace eval ::tc_PENTIUM3gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PENTIUM3gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PENTIUM3gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldpentium $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PENTIUM3gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PENTIUM3
    }

    proc archDir {} {
	return i86
    }

    proc name {} {
	return PENTIUM3gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccpentium -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PENTIUM3gnu
}
set tcInfo_PENTIUM4gnu(TOOL_FAMILY) gnu
set tcInfo_PENTIUM4gnu(CC) "ccpentium"
set tcInfo_PENTIUM4gnu(CPP) "ccpentium -E -P"
set tcInfo_PENTIUM4gnu(AS) "ccpentium"
set tcInfo_PENTIUM4gnu(LD) "ldpentium"
set tcInfo_PENTIUM4gnu(LD_PARTIAL) "ccpentium -r -nostdlib -Wl,-X"
set tcInfo_PENTIUM4gnu(NM) "nmpentium -g"
set tcInfo_PENTIUM4gnu(SIZE) "sizepentium"
set tcInfo_PENTIUM4gnu(AR) "arpentium"
set tcInfo_PENTIUM4gnu(CFLAGS) {-g -mtune=pentium4 -march=pentium4 -nostdlib -fno-builtin -fno-defer-pop -ansi -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PENTIUM4gnu(CFLAGS_AS) {-g -mtune=pentium4 -march=pentium4 -nostdlib -fno-builtin -fno-defer-pop -ansi -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PENTIUM4gnu(LDFLAGS) "-X -N"
set tcInfo_PENTIUM4gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PENTIUM4gnu(HEX_FLAGS) ""
set tcInfo_PENTIUM4gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PENTIUM4gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PENTIUM4gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PENTIUM4gnu(OPTION_LANG_C) -xc
set tcInfo_PENTIUM4gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PENTIUM4gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PENTIUM4gnu(CC_ARCH_SPEC) "-mtune=pentium4 -march=pentium4 -nostdlib -fno-builtin -fno-defer-pop"
namespace eval ::tc_PENTIUM4gnu { }

set tc_PENTIUM4gnu::tcname(undef_undef) gnu

namespace eval ::tc_PENTIUM4gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PENTIUM4gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PENTIUM4gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldpentium $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PENTIUM4gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PENTIUM4
    }

    proc archDir {} {
	return i86
    }

    proc name {} {
	return PENTIUM4gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccpentium -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PENTIUM4gnu
}
set tcInfo_PENTIUMgnu(TOOL_FAMILY) gnu
set tcInfo_PENTIUMgnu(CC) "ccpentium"
set tcInfo_PENTIUMgnu(CPP) "ccpentium -E -P"
set tcInfo_PENTIUMgnu(AS) "ccpentium"
set tcInfo_PENTIUMgnu(LD) "ldpentium"
set tcInfo_PENTIUMgnu(LD_PARTIAL) "ccpentium -r -nostdlib -Wl,-X"
set tcInfo_PENTIUMgnu(NM) "nmpentium -g"
set tcInfo_PENTIUMgnu(SIZE) "sizepentium"
set tcInfo_PENTIUMgnu(AR) "arpentium"
set tcInfo_PENTIUMgnu(CFLAGS) {-g -mtune=pentium -march=pentium -nostdlib -fno-builtin -fno-defer-pop -ansi -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PENTIUMgnu(CFLAGS_AS) {-g -mtune=pentium -march=pentium -nostdlib -fno-builtin -fno-defer-pop -ansi -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PENTIUMgnu(LDFLAGS) "-X -N"
set tcInfo_PENTIUMgnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PENTIUMgnu(HEX_FLAGS) ""
set tcInfo_PENTIUMgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PENTIUMgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PENTIUMgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PENTIUMgnu(OPTION_LANG_C) -xc
set tcInfo_PENTIUMgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PENTIUMgnu(OPTION_DEPEND) "-M -w"
set tcInfo_PENTIUMgnu(CC_ARCH_SPEC) "-mtune=pentium -march=pentium -nostdlib -fno-builtin -fno-defer-pop"
namespace eval ::tc_PENTIUMgnu { }

set tc_PENTIUMgnu::tcname(undef_undef) gnu

namespace eval ::tc_PENTIUMgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PENTIUMgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PENTIUMgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldpentium $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PENTIUMgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PENTIUM
    }

    proc archDir {} {
	return i86
    }

    proc name {} {
	return PENTIUMgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccpentium -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PENTIUMgnu
}
set tcInfo_PPC32e500v2gnu(TOOL_FAMILY) gnu
set tcInfo_PPC32e500v2gnu(CC) "ccppc"
set tcInfo_PPC32e500v2gnu(CPP) "ccppc -E -P"
set tcInfo_PPC32e500v2gnu(AS) "ccppc"
set tcInfo_PPC32e500v2gnu(LD) "ldppc"
set tcInfo_PPC32e500v2gnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC32e500v2gnu(NM) "nmppc"
set tcInfo_PPC32e500v2gnu(SIZE) "sizeppc"
set tcInfo_PPC32e500v2gnu(AR) "arppc"
set tcInfo_PPC32e500v2gnu(CFLAGS) {-g -te500v2 -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC32e500v2gnu(CFLAGS_AS) {-g -te500v2 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC32e500v2gnu(LDFLAGS) "-X -N"
set tcInfo_PPC32e500v2gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC32e500v2gnu(HEX_FLAGS) ""
set tcInfo_PPC32e500v2gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC32e500v2gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC32e500v2gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC32e500v2gnu(OPTION_LANG_C) -xc
set tcInfo_PPC32e500v2gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC32e500v2gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC32e500v2gnu(CC_ARCH_SPEC) "-te500v2"
namespace eval ::tc_PPC32gnu { }

set tc_PPC32gnu::tcname(big_e500v2) e500v2gnu

namespace eval ::tc_PPC32e500v2gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC32e500v2gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC32e500v2gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC32e500v2gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return e500v2gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC32
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC32e500v2gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return e500v2
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC32e500v2gnu
}
set tcInfo_PPC32gnu(TOOL_FAMILY) gnu
set tcInfo_PPC32gnu(CC) "ccppc"
set tcInfo_PPC32gnu(CPP) "ccppc -E -P"
set tcInfo_PPC32gnu(AS) "ccppc"
set tcInfo_PPC32gnu(LD) "ldppc"
set tcInfo_PPC32gnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC32gnu(NM) "nmppc"
set tcInfo_PPC32gnu(SIZE) "sizeppc"
set tcInfo_PPC32gnu(AR) "arppc"
set tcInfo_PPC32gnu(CFLAGS) {-g -mhard-float -mstrict-align -fno-implicit-fp -DPPC32_fp60x -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC32gnu(CFLAGS_AS) {-g -mhard-float -mstrict-align -fno-implicit-fp -DPPC32_fp60x -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC32gnu(LDFLAGS) "-X -N"
set tcInfo_PPC32gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC32gnu(HEX_FLAGS) ""
set tcInfo_PPC32gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC32gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC32gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC32gnu(OPTION_LANG_C) -xc
set tcInfo_PPC32gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC32gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC32gnu(CC_ARCH_SPEC) "-mhard-float -mstrict-align -fno-implicit-fp -DPPC32_fp60x"
namespace eval ::tc_PPC32gnu { }

set tc_PPC32gnu::tcname(big_hard) gnu

namespace eval ::tc_PPC32gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC32gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC32gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC32gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC32
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC32gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC32gnu
}
set tcInfo_PPC32sfgnu(TOOL_FAMILY) gnu
set tcInfo_PPC32sfgnu(CC) "ccppc"
set tcInfo_PPC32sfgnu(CPP) "ccppc -E -P"
set tcInfo_PPC32sfgnu(AS) "ccppc"
set tcInfo_PPC32sfgnu(LD) "ldppc"
set tcInfo_PPC32sfgnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC32sfgnu(NM) "nmppc"
set tcInfo_PPC32sfgnu(SIZE) "sizeppc"
set tcInfo_PPC32sfgnu(AR) "arppc"
set tcInfo_PPC32sfgnu(CFLAGS) {-g -msoft-float -mstrict-align -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC32sfgnu(CFLAGS_AS) {-g -msoft-float -mstrict-align -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC32sfgnu(LDFLAGS) "-X -N"
set tcInfo_PPC32sfgnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC32sfgnu(HEX_FLAGS) ""
set tcInfo_PPC32sfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC32sfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC32sfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC32sfgnu(OPTION_LANG_C) -xc
set tcInfo_PPC32sfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC32sfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC32sfgnu(CC_ARCH_SPEC) "-msoft-float -mstrict-align"
namespace eval ::tc_PPC32gnu { }

set tc_PPC32gnu::tcname(big_soft) sfgnu

namespace eval ::tc_PPC32sfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC32sfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC32sfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC32sfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC32
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC32sfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC32sfgnu
}
set tcInfo_PPC403gnu(TOOL_FAMILY) gnu
set tcInfo_PPC403gnu(CC) "ccppc"
set tcInfo_PPC403gnu(CPP) "ccppc -E -P"
set tcInfo_PPC403gnu(AS) "ccppc"
set tcInfo_PPC403gnu(LD) "ldppc"
set tcInfo_PPC403gnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC403gnu(NM) "nmppc"
set tcInfo_PPC403gnu(SIZE) "sizeppc"
set tcInfo_PPC403gnu(AR) "arppc"
set tcInfo_PPC403gnu(CFLAGS) {-g -mcpu=403 -mstrict-align -msoft-float -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC403gnu(CFLAGS_AS) {-g -mcpu=403 -mstrict-align -msoft-float -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC403gnu(LDFLAGS) "-X -N"
set tcInfo_PPC403gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC403gnu(HEX_FLAGS) ""
set tcInfo_PPC403gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC403gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC403gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC403gnu(OPTION_LANG_C) -xc
set tcInfo_PPC403gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC403gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC403gnu(CC_ARCH_SPEC) "-mcpu=403 -mstrict-align -msoft-float"
namespace eval ::tc_PPC403gnu { }

set tc_PPC403gnu::tcname(big_soft) gnu

namespace eval ::tc_PPC403gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC403gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC403gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC403gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC403
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC403gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC403gnu
}
set tcInfo_PPC405gnu(TOOL_FAMILY) gnu
set tcInfo_PPC405gnu(CC) "ccppc"
set tcInfo_PPC405gnu(CPP) "ccppc -E -P"
set tcInfo_PPC405gnu(AS) "ccppc"
set tcInfo_PPC405gnu(LD) "ldppc"
set tcInfo_PPC405gnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC405gnu(NM) "nmppc"
set tcInfo_PPC405gnu(SIZE) "sizeppc"
set tcInfo_PPC405gnu(AR) "arppc"
set tcInfo_PPC405gnu(CFLAGS) {-g -mcpu=405 -mstrict-align -msoft-float -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC405gnu(CFLAGS_AS) {-g -mcpu=405 -mstrict-align -msoft-float -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC405gnu(LDFLAGS) "-X -N"
set tcInfo_PPC405gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC405gnu(HEX_FLAGS) ""
set tcInfo_PPC405gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC405gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC405gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC405gnu(OPTION_LANG_C) -xc
set tcInfo_PPC405gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC405gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC405gnu(CC_ARCH_SPEC) "-mcpu=405 -mstrict-align -msoft-float"
namespace eval ::tc_PPC405gnu { }

set tc_PPC405gnu::tcname(big_soft) gnu

namespace eval ::tc_PPC405gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC405gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC405gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC405gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC405
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC405gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC405gnu
}
set tcInfo_PPC405sfgnu(TOOL_FAMILY) gnu
set tcInfo_PPC405sfgnu(CC) "ccppc"
set tcInfo_PPC405sfgnu(CPP) "ccppc -E -P"
set tcInfo_PPC405sfgnu(AS) "ccppc"
set tcInfo_PPC405sfgnu(LD) "ldppc"
set tcInfo_PPC405sfgnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC405sfgnu(NM) "nmppc"
set tcInfo_PPC405sfgnu(SIZE) "sizeppc"
set tcInfo_PPC405sfgnu(AR) "arppc"
set tcInfo_PPC405sfgnu(CFLAGS) {-g -mcpu=405 -mstrict-align -msoft-float -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC405sfgnu(CFLAGS_AS) {-g -mcpu=405 -mstrict-align -msoft-float -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC405sfgnu(LDFLAGS) "-X -N"
set tcInfo_PPC405sfgnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC405sfgnu(HEX_FLAGS) ""
set tcInfo_PPC405sfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC405sfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC405sfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC405sfgnu(OPTION_LANG_C) -xc
set tcInfo_PPC405sfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC405sfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC405sfgnu(CC_ARCH_SPEC) "-mcpu=405 -mstrict-align -msoft-float"
namespace eval ::tc_PPC405gnu { }

set tc_PPC405gnu::tcname(big_soft) sfgnu

namespace eval ::tc_PPC405sfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC405sfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC405sfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC405sfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC405
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC405sfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC405sfgnu
}
set tcInfo_PPC440gnu(TOOL_FAMILY) gnu
set tcInfo_PPC440gnu(CC) "ccppc"
set tcInfo_PPC440gnu(CPP) "ccppc -E -P"
set tcInfo_PPC440gnu(AS) "ccppc"
set tcInfo_PPC440gnu(LD) "ldppc"
set tcInfo_PPC440gnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC440gnu(NM) "nmppc"
set tcInfo_PPC440gnu(SIZE) "sizeppc"
set tcInfo_PPC440gnu(AR) "arppc"
set tcInfo_PPC440gnu(CFLAGS) {-g -mcpu=440 -mstrict-align -msoft-float -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC440gnu(CFLAGS_AS) {-g -mcpu=440 -mstrict-align -msoft-float -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC440gnu(LDFLAGS) "-X -N"
set tcInfo_PPC440gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC440gnu(HEX_FLAGS) ""
set tcInfo_PPC440gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC440gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC440gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC440gnu(OPTION_LANG_C) -xc
set tcInfo_PPC440gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC440gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC440gnu(CC_ARCH_SPEC) "-mcpu=440 -mstrict-align -msoft-float"
namespace eval ::tc_PPC440gnu { }

set tc_PPC440gnu::tcname(big_soft) gnu

namespace eval ::tc_PPC440gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC440gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC440gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC440gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC440
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC440gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC440gnu
}
set tcInfo_PPC440sfgnu(TOOL_FAMILY) gnu
set tcInfo_PPC440sfgnu(CC) "ccppc"
set tcInfo_PPC440sfgnu(CPP) "ccppc -E -P"
set tcInfo_PPC440sfgnu(AS) "ccppc"
set tcInfo_PPC440sfgnu(LD) "ldppc"
set tcInfo_PPC440sfgnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC440sfgnu(NM) "nmppc"
set tcInfo_PPC440sfgnu(SIZE) "sizeppc"
set tcInfo_PPC440sfgnu(AR) "arppc"
set tcInfo_PPC440sfgnu(CFLAGS) {-g -mcpu=440 -mstrict-align -msoft-float -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC440sfgnu(CFLAGS_AS) {-g -mcpu=440 -mstrict-align -msoft-float -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC440sfgnu(LDFLAGS) "-X -N"
set tcInfo_PPC440sfgnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC440sfgnu(HEX_FLAGS) ""
set tcInfo_PPC440sfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC440sfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC440sfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC440sfgnu(OPTION_LANG_C) -xc
set tcInfo_PPC440sfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC440sfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC440sfgnu(CC_ARCH_SPEC) "-mcpu=440 -mstrict-align -msoft-float"
namespace eval ::tc_PPC440gnu { }

set tc_PPC440gnu::tcname(big_soft) sfgnu

namespace eval ::tc_PPC440sfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC440sfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC440sfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC440sfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC440
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC440sfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC440sfgnu
}
set tcInfo_PPC603gnu(TOOL_FAMILY) gnu
set tcInfo_PPC603gnu(CC) "ccppc"
set tcInfo_PPC603gnu(CPP) "ccppc -E -P"
set tcInfo_PPC603gnu(AS) "ccppc"
set tcInfo_PPC603gnu(LD) "ldppc"
set tcInfo_PPC603gnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC603gnu(NM) "nmppc"
set tcInfo_PPC603gnu(SIZE) "sizeppc"
set tcInfo_PPC603gnu(AR) "arppc"
set tcInfo_PPC603gnu(CFLAGS) {-g -mcpu=603 -mstrict-align -fno-implicit-fp -D_WRS_HARDWARE_FP -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC603gnu(CFLAGS_AS) {-g -mcpu=603 -mstrict-align -fno-implicit-fp -D_WRS_HARDWARE_FP -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC603gnu(LDFLAGS) "-X -N"
set tcInfo_PPC603gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC603gnu(HEX_FLAGS) ""
set tcInfo_PPC603gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC603gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC603gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC603gnu(OPTION_LANG_C) -xc
set tcInfo_PPC603gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC603gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC603gnu(CC_ARCH_SPEC) "-mcpu=603 -mstrict-align -fno-implicit-fp -D_WRS_HARDWARE_FP"
namespace eval ::tc_PPC603gnu { }

set tc_PPC603gnu::tcname(big_hard) gnu

namespace eval ::tc_PPC603gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC603gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC603gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC603gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC603
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC603gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC603gnu
}
set tcInfo_PPC604gnu(TOOL_FAMILY) gnu
set tcInfo_PPC604gnu(CC) "ccppc"
set tcInfo_PPC604gnu(CPP) "ccppc -E -P"
set tcInfo_PPC604gnu(AS) "ccppc"
set tcInfo_PPC604gnu(LD) "ldppc"
set tcInfo_PPC604gnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC604gnu(NM) "nmppc"
set tcInfo_PPC604gnu(SIZE) "sizeppc"
set tcInfo_PPC604gnu(AR) "arppc"
set tcInfo_PPC604gnu(CFLAGS) {-g -mcpu=604 -mstrict-align -fno-implicit-fp -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC604gnu(CFLAGS_AS) {-g -mcpu=604 -mstrict-align -fno-implicit-fp -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC604gnu(LDFLAGS) "-X -N"
set tcInfo_PPC604gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC604gnu(HEX_FLAGS) ""
set tcInfo_PPC604gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC604gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC604gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC604gnu(OPTION_LANG_C) -xc
set tcInfo_PPC604gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC604gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC604gnu(CC_ARCH_SPEC) "-mcpu=604 -mstrict-align -fno-implicit-fp"
namespace eval ::tc_PPC604gnu { }

set tc_PPC604gnu::tcname(big_hard) gnu

namespace eval ::tc_PPC604gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC604gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC604gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC604gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC604
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC604gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC604gnu
}
set tcInfo_PPC85XXe500v2gnu(TOOL_FAMILY) gnu
set tcInfo_PPC85XXe500v2gnu(CC) "ccppc"
set tcInfo_PPC85XXe500v2gnu(CPP) "ccppc -E -P"
set tcInfo_PPC85XXe500v2gnu(AS) "ccppc"
set tcInfo_PPC85XXe500v2gnu(LD) "ldppc"
set tcInfo_PPC85XXe500v2gnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC85XXe500v2gnu(NM) "nmppc"
set tcInfo_PPC85XXe500v2gnu(SIZE) "sizeppc"
set tcInfo_PPC85XXe500v2gnu(AR) "arppc"
set tcInfo_PPC85XXe500v2gnu(CFLAGS) {-g -te500v2 -mcpu=8548 -mfloat-gprs=double -mspe=yes -mabi=spe -mstrict-align -fno-implicit-fp -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC85XXe500v2gnu(CFLAGS_AS) {-g -te500v2 -mcpu=8548 -mfloat-gprs=double -mspe=yes -mabi=spe -mstrict-align -fno-implicit-fp -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC85XXe500v2gnu(LDFLAGS) "-X -N"
set tcInfo_PPC85XXe500v2gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC85XXe500v2gnu(HEX_FLAGS) ""
set tcInfo_PPC85XXe500v2gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC85XXe500v2gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC85XXe500v2gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC85XXe500v2gnu(OPTION_LANG_C) -xc
set tcInfo_PPC85XXe500v2gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC85XXe500v2gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC85XXe500v2gnu(CC_ARCH_SPEC) "-te500v2 -mcpu=8548 -mfloat-gprs=double -mspe=yes -mabi=spe  -mstrict-align -fno-implicit-fp"
namespace eval ::tc_PPC85XXgnu { }

set tc_PPC85XXgnu::tcname(big_e500v2) e500v2gnu

namespace eval ::tc_PPC85XXe500v2gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC85XXe500v2gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC85XXe500v2gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC85XXe500v2gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return e500v2gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC85XX
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC85XXe500v2gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return e500v2
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC85XXe500v2gnu
}
set tcInfo_PPC85XXgnu(TOOL_FAMILY) gnu
set tcInfo_PPC85XXgnu(CC) "ccppc"
set tcInfo_PPC85XXgnu(CPP) "ccppc -E -P"
set tcInfo_PPC85XXgnu(AS) "ccppc"
set tcInfo_PPC85XXgnu(LD) "ldppc"
set tcInfo_PPC85XXgnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC85XXgnu(NM) "nmppc"
set tcInfo_PPC85XXgnu(SIZE) "sizeppc"
set tcInfo_PPC85XXgnu(AR) "arppc"
set tcInfo_PPC85XXgnu(CFLAGS) {-g -mcpu=8540 -mstrict-align -msoft-float -mabi=no-spe -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC85XXgnu(CFLAGS_AS) {-g -mcpu=8540 -mstrict-align -msoft-float -mabi=no-spe -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC85XXgnu(LDFLAGS) "-X -N"
set tcInfo_PPC85XXgnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC85XXgnu(HEX_FLAGS) ""
set tcInfo_PPC85XXgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC85XXgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC85XXgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC85XXgnu(OPTION_LANG_C) -xc
set tcInfo_PPC85XXgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC85XXgnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC85XXgnu(CC_ARCH_SPEC) "-mcpu=8540 -mstrict-align -msoft-float -mabi=no-spe"
namespace eval ::tc_PPC85XXgnu { }

set tc_PPC85XXgnu::tcname(big_soft) gnu

namespace eval ::tc_PPC85XXgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC85XXgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC85XXgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC85XXgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC85XX
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC85XXgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC85XXgnu
}
set tcInfo_PPC85XXsfgnu(TOOL_FAMILY) gnu
set tcInfo_PPC85XXsfgnu(CC) "ccppc"
set tcInfo_PPC85XXsfgnu(CPP) "ccppc -E -P"
set tcInfo_PPC85XXsfgnu(AS) "ccppc"
set tcInfo_PPC85XXsfgnu(LD) "ldppc"
set tcInfo_PPC85XXsfgnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC85XXsfgnu(NM) "nmppc"
set tcInfo_PPC85XXsfgnu(SIZE) "sizeppc"
set tcInfo_PPC85XXsfgnu(AR) "arppc"
set tcInfo_PPC85XXsfgnu(CFLAGS) {-g -mcpu=8540 -mstrict-align -msoft-float -mabi=no-spe -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC85XXsfgnu(CFLAGS_AS) {-g -mcpu=8540 -mstrict-align -msoft-float -mabi=no-spe -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC85XXsfgnu(LDFLAGS) "-X -N"
set tcInfo_PPC85XXsfgnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC85XXsfgnu(HEX_FLAGS) ""
set tcInfo_PPC85XXsfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC85XXsfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC85XXsfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC85XXsfgnu(OPTION_LANG_C) -xc
set tcInfo_PPC85XXsfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC85XXsfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC85XXsfgnu(CC_ARCH_SPEC) "-mcpu=8540 -mstrict-align -msoft-float -mabi=no-spe"
namespace eval ::tc_PPC85XXgnu { }

set tc_PPC85XXgnu::tcname(big_soft) sfgnu

namespace eval ::tc_PPC85XXsfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC85XXsfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC85XXsfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC85XXsfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC85XX
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC85XXsfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC85XXsfgnu
}
set tcInfo_PPC860gnu(TOOL_FAMILY) gnu
set tcInfo_PPC860gnu(CC) "ccppc"
set tcInfo_PPC860gnu(CPP) "ccppc -E -P"
set tcInfo_PPC860gnu(AS) "ccppc"
set tcInfo_PPC860gnu(LD) "ldppc"
set tcInfo_PPC860gnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC860gnu(NM) "nmppc"
set tcInfo_PPC860gnu(SIZE) "sizeppc"
set tcInfo_PPC860gnu(AR) "arppc"
set tcInfo_PPC860gnu(CFLAGS) {-g -mcpu=860 -mstrict-align -msoft-float -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC860gnu(CFLAGS_AS) {-g -mcpu=860 -mstrict-align -msoft-float -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC860gnu(LDFLAGS) "-X -N"
set tcInfo_PPC860gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC860gnu(HEX_FLAGS) ""
set tcInfo_PPC860gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC860gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC860gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC860gnu(OPTION_LANG_C) -xc
set tcInfo_PPC860gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC860gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC860gnu(CC_ARCH_SPEC) "-mcpu=860 -mstrict-align -msoft-float"
namespace eval ::tc_PPC860gnu { }

set tc_PPC860gnu::tcname(big_soft) gnu

namespace eval ::tc_PPC860gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC860gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC860gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC860gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC860
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC860gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC860gnu
}
set tcInfo_PPC860sfgnu(TOOL_FAMILY) gnu
set tcInfo_PPC860sfgnu(CC) "ccppc"
set tcInfo_PPC860sfgnu(CPP) "ccppc -E -P"
set tcInfo_PPC860sfgnu(AS) "ccppc"
set tcInfo_PPC860sfgnu(LD) "ldppc"
set tcInfo_PPC860sfgnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC860sfgnu(NM) "nmppc"
set tcInfo_PPC860sfgnu(SIZE) "sizeppc"
set tcInfo_PPC860sfgnu(AR) "arppc"
set tcInfo_PPC860sfgnu(CFLAGS) {-g -mcpu=860 -mstrict-align -msoft-float -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC860sfgnu(CFLAGS_AS) {-g -mcpu=860 -mstrict-align -msoft-float -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC860sfgnu(LDFLAGS) "-X -N"
set tcInfo_PPC860sfgnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC860sfgnu(HEX_FLAGS) ""
set tcInfo_PPC860sfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC860sfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC860sfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC860sfgnu(OPTION_LANG_C) -xc
set tcInfo_PPC860sfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC860sfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC860sfgnu(CC_ARCH_SPEC) "-mcpu=860 -mstrict-align -msoft-float"
namespace eval ::tc_PPC860gnu { }

set tc_PPC860gnu::tcname(big_soft) sfgnu

namespace eval ::tc_PPC860sfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC860sfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC860sfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC860sfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC860
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC860sfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC860sfgnu
}
set tcInfo_PPC970gnu(TOOL_FAMILY) gnu
set tcInfo_PPC970gnu(CC) "ccppc"
set tcInfo_PPC970gnu(CPP) "ccppc -E -P"
set tcInfo_PPC970gnu(AS) "ccppc"
set tcInfo_PPC970gnu(LD) "ldppc"
set tcInfo_PPC970gnu(LD_PARTIAL) "ccppc -r -nostdlib -Wl,-X"
set tcInfo_PPC970gnu(NM) "nmppc"
set tcInfo_PPC970gnu(SIZE) "sizeppc"
set tcInfo_PPC970gnu(AR) "arppc"
set tcInfo_PPC970gnu(CFLAGS) {-g -mcpu=power4 -Wa,-mppc64bridge -mstrict-align -fno-implicit-fp -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC970gnu(CFLAGS_AS) {-g -mcpu=power4 -Wa,-mppc64bridge -mstrict-align -fno-implicit-fp -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_PPC970gnu(LDFLAGS) "-X -N"
set tcInfo_PPC970gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_PPC970gnu(HEX_FLAGS) ""
set tcInfo_PPC970gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_PPC970gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_PPC970gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_PPC970gnu(OPTION_LANG_C) -xc
set tcInfo_PPC970gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_PPC970gnu(OPTION_DEPEND) "-M -w"
set tcInfo_PPC970gnu(CC_ARCH_SPEC) "-mcpu=power4 -Wa,-mppc64bridge -mstrict-align -fno-implicit-fp"
namespace eval ::tc_PPC970gnu { }

set tc_PPC970gnu::tcname(big_hard) gnu

namespace eval ::tc_PPC970gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_PPC970gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_PPC970gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldppc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_PPC970gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return PPC970
    }

    proc archDir {} {
	return ppc
    }

    proc name {} {
	return PPC970gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccppc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_PPC970gnu
}
set tcInfo_SH7600gnu(TOOL_FAMILY) gnu
set tcInfo_SH7600gnu(CC) "ccsh"
set tcInfo_SH7600gnu(CPP) "ccsh -E -P"
set tcInfo_SH7600gnu(AS) "ccsh"
set tcInfo_SH7600gnu(LD) "ldsh"
set tcInfo_SH7600gnu(LD_PARTIAL) "ccsh -r -nostdlib -Wl,-X"
set tcInfo_SH7600gnu(NM) "nmsh -g"
set tcInfo_SH7600gnu(SIZE) "sizesh"
set tcInfo_SH7600gnu(AR) "arsh"
set tcInfo_SH7600gnu(CFLAGS) {-g -m2 -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SH7600gnu(CFLAGS_AS) {-g -m2 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SH7600gnu(LDFLAGS) "-X -n"
set tcInfo_SH7600gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_SH7600gnu(HEX_FLAGS) ""
set tcInfo_SH7600gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_SH7600gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_SH7600gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_SH7600gnu(OPTION_LANG_C) -xc
set tcInfo_SH7600gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_SH7600gnu(OPTION_DEPEND) "-M -w"
set tcInfo_SH7600gnu(CC_ARCH_SPEC) "-m2"
namespace eval ::tc_SH7600gnu { }

set tc_SH7600gnu::tcname(big_hard) gnu

namespace eval ::tc_SH7600gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_SH7600gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_SH7600gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldsh $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_SH7600gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return SH7600
    }

    proc archDir {} {
	return sh
    }

    proc name {} {
	return SH7600gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccsh -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_SH7600gnu
}
set tcInfo_SH7700gnu(TOOL_FAMILY) gnu
set tcInfo_SH7700gnu(CC) "ccsh"
set tcInfo_SH7700gnu(CPP) "ccsh -E -P"
set tcInfo_SH7700gnu(AS) "ccsh"
set tcInfo_SH7700gnu(LD) "ldsh"
set tcInfo_SH7700gnu(LD_PARTIAL) "ccsh -r -nostdlib -Wl,-X"
set tcInfo_SH7700gnu(NM) "nmsh -g"
set tcInfo_SH7700gnu(SIZE) "sizesh"
set tcInfo_SH7700gnu(AR) "arsh"
set tcInfo_SH7700gnu(CFLAGS) {-g -m3 -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SH7700gnu(CFLAGS_AS) {-g -m3 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SH7700gnu(LDFLAGS) "-X -n"
set tcInfo_SH7700gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_SH7700gnu(HEX_FLAGS) ""
set tcInfo_SH7700gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_SH7700gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_SH7700gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_SH7700gnu(OPTION_LANG_C) -xc
set tcInfo_SH7700gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_SH7700gnu(OPTION_DEPEND) "-M -w"
set tcInfo_SH7700gnu(CC_ARCH_SPEC) "-m3"
namespace eval ::tc_SH7700gnu { }

set tc_SH7700gnu::tcname(big_hard) gnu

namespace eval ::tc_SH7700gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_SH7700gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_SH7700gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldsh $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_SH7700gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return SH7700
    }

    proc archDir {} {
	return sh
    }

    proc name {} {
	return SH7700gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccsh -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_SH7700gnu
}
set tcInfo_SH7700gnule(TOOL_FAMILY) gnu
set tcInfo_SH7700gnule(CC) "ccsh"
set tcInfo_SH7700gnule(CPP) "ccsh -E -P"
set tcInfo_SH7700gnule(AS) "ccsh"
set tcInfo_SH7700gnule(LD) "ldsh"
set tcInfo_SH7700gnule(LD_PARTIAL) "ccsh -r -nostdlib -Wl,-X -Wl,-EL"
set tcInfo_SH7700gnule(NM) "nmsh -g"
set tcInfo_SH7700gnule(SIZE) "sizesh"
set tcInfo_SH7700gnule(AR) "arsh"
set tcInfo_SH7700gnule(CFLAGS) {-g -m3 -ml -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SH7700gnule(CFLAGS_AS) {-g -m3 -ml -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SH7700gnule(LDFLAGS) "-X -n -EL"
set tcInfo_SH7700gnule(LD_PARTIAL_FLAGS) "-X -r -EL"
set tcInfo_SH7700gnule(HEX_FLAGS) ""
set tcInfo_SH7700gnule(OPTION_INCLUDE_DIR) -I
set tcInfo_SH7700gnule(OPTION_DEFINE_MACRO) -D
set tcInfo_SH7700gnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_SH7700gnule(OPTION_LANG_C) -xc
set tcInfo_SH7700gnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_SH7700gnule(OPTION_DEPEND) "-M -w"
set tcInfo_SH7700gnule(CC_ARCH_SPEC) "-m3 -ml"
namespace eval ::tc_SH7700gnu { }

set tc_SH7700gnu::tcname(little_hard) gnule

namespace eval ::tc_SH7700gnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_SH7700gnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_SH7700gnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldsh $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_SH7700gnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return SH7700
    }

    proc archDir {} {
	return sh
    }

    proc name {} {
	return SH7700gnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccsh -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_SH7700gnule
}
set tcInfo_SH7750gnu(TOOL_FAMILY) gnu
set tcInfo_SH7750gnu(CC) "ccsh"
set tcInfo_SH7750gnu(CPP) "ccsh -E -P"
set tcInfo_SH7750gnu(AS) "ccsh"
set tcInfo_SH7750gnu(LD) "ldsh"
set tcInfo_SH7750gnu(LD_PARTIAL) "ccsh -r -nostdlib -Wl,-X"
set tcInfo_SH7750gnu(NM) "nmsh -g"
set tcInfo_SH7750gnu(SIZE) "sizesh"
set tcInfo_SH7750gnu(AR) "arsh"
set tcInfo_SH7750gnu(CFLAGS) {-g -m4 -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SH7750gnu(CFLAGS_AS) {-g -m4 -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SH7750gnu(LDFLAGS) "-X -n"
set tcInfo_SH7750gnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_SH7750gnu(HEX_FLAGS) ""
set tcInfo_SH7750gnu(OPTION_INCLUDE_DIR) -I
set tcInfo_SH7750gnu(OPTION_DEFINE_MACRO) -D
set tcInfo_SH7750gnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_SH7750gnu(OPTION_LANG_C) -xc
set tcInfo_SH7750gnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_SH7750gnu(OPTION_DEPEND) "-M -w"
set tcInfo_SH7750gnu(CC_ARCH_SPEC) "-m4"
namespace eval ::tc_SH7750gnu { }

set tc_SH7750gnu::tcname(big_hard) gnu

namespace eval ::tc_SH7750gnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_SH7750gnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_SH7750gnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldsh $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_SH7750gnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return SH7750
    }

    proc archDir {} {
	return sh
    }

    proc name {} {
	return SH7750gnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccsh -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_SH7750gnu
}
set tcInfo_SH7750gnule(TOOL_FAMILY) gnu
set tcInfo_SH7750gnule(CC) "ccsh"
set tcInfo_SH7750gnule(CPP) "ccsh -E -P"
set tcInfo_SH7750gnule(AS) "ccsh"
set tcInfo_SH7750gnule(LD) "ldsh"
set tcInfo_SH7750gnule(LD_PARTIAL) "ccsh -r -nostdlib -Wl,-X -Wl,-EL"
set tcInfo_SH7750gnule(NM) "nmsh -g"
set tcInfo_SH7750gnule(SIZE) "sizesh"
set tcInfo_SH7750gnule(AR) "arsh"
set tcInfo_SH7750gnule(CFLAGS) {-g -m4 -ml -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SH7750gnule(CFLAGS_AS) {-g -m4 -ml -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SH7750gnule(LDFLAGS) "-X -n -EL"
set tcInfo_SH7750gnule(LD_PARTIAL_FLAGS) "-X -r -EL"
set tcInfo_SH7750gnule(HEX_FLAGS) ""
set tcInfo_SH7750gnule(OPTION_INCLUDE_DIR) -I
set tcInfo_SH7750gnule(OPTION_DEFINE_MACRO) -D
set tcInfo_SH7750gnule(OPTION_UNDEFINE_MACRO) -U
set tcInfo_SH7750gnule(OPTION_LANG_C) -xc
set tcInfo_SH7750gnule(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_SH7750gnule(OPTION_DEPEND) "-M -w"
set tcInfo_SH7750gnule(CC_ARCH_SPEC) "-m4 -ml"
namespace eval ::tc_SH7750gnu { }

set tc_SH7750gnu::tcname(little_hard) gnule

namespace eval ::tc_SH7750gnule::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_SH7750gnule::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_SH7750gnule::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldsh $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_SH7750gnule {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnule
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return SH7750
    }

    proc archDir {} {
	return sh
    }

    proc name {} {
	return SH7750gnule
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccsh -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return "_"
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return hard
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_SH7750gnule
}
set tcInfo_SIMLINUXgnu(TOOL_FAMILY) gnu
set tcInfo_SIMLINUXgnu(CC) "ccpentium"
set tcInfo_SIMLINUXgnu(CPP) "ccpentium -E -P"
set tcInfo_SIMLINUXgnu(AS) "ccpentium"
set tcInfo_SIMLINUXgnu(LD) "ldpentium"
set tcInfo_SIMLINUXgnu(LD_PARTIAL) "ccpentium -r -nostdlib -Wl,-X"
set tcInfo_SIMLINUXgnu(NM) "nmpentium -g"
set tcInfo_SIMLINUXgnu(SIZE) "sizepentium"
set tcInfo_SIMLINUXgnu(AR) "arpentium"
set tcInfo_SIMLINUXgnu(CFLAGS) {-g -mtune=i486 -march=i486 -ansi -nostdlib -fno-builtin -fno-defer-pop -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SIMLINUXgnu(CFLAGS_AS) {-g -mtune=i486 -march=i486 -ansi -nostdlib -fno-builtin -fno-defer-pop -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SIMLINUXgnu(LDFLAGS) "-X -N"
set tcInfo_SIMLINUXgnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_SIMLINUXgnu(HEX_FLAGS) ""
set tcInfo_SIMLINUXgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_SIMLINUXgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_SIMLINUXgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_SIMLINUXgnu(OPTION_LANG_C) -xc
set tcInfo_SIMLINUXgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_SIMLINUXgnu(OPTION_DEPEND) "-M -w"
set tcInfo_SIMLINUXgnu(CC_ARCH_SPEC) "-mtune=i486 -march=i486"
namespace eval ::tc_SIMLINUXgnu { }

set tc_SIMLINUXgnu::tcname(undef_undef) gnu

namespace eval ::tc_SIMLINUXgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_SIMLINUXgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_SIMLINUXgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldpentium $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_SIMLINUXgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return SIMLINUX
    }

    proc archDir {} {
	return simlinux
    }

    proc name {} {
	return SIMLINUXgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccpentium -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_SIMLINUXgnu
}
set tcInfo_SIMNTgnu(TOOL_FAMILY) gnu
set tcInfo_SIMNTgnu(CC) "ccpentium"
set tcInfo_SIMNTgnu(CPP) "ccpentium -E -P"
set tcInfo_SIMNTgnu(AS) "ccpentium"
set tcInfo_SIMNTgnu(LD) "ldpentium"
set tcInfo_SIMNTgnu(LD_PARTIAL) "ccpentium -r -nostdlib -Wl,-X"
set tcInfo_SIMNTgnu(NM) "nmpentium -g"
set tcInfo_SIMNTgnu(SIZE) "sizepentium"
set tcInfo_SIMNTgnu(AR) "arpentium"
set tcInfo_SIMNTgnu(CFLAGS) {-g -mtune=i486 -march=i486 -ansi -nostdlib -fno-builtin -fno-defer-pop -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SIMNTgnu(CFLAGS_AS) {-g -mtune=i486 -march=i486 -ansi -nostdlib -fno-builtin -fno-defer-pop -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SIMNTgnu(LDFLAGS) "-X -N"
set tcInfo_SIMNTgnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_SIMNTgnu(HEX_FLAGS) ""
set tcInfo_SIMNTgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_SIMNTgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_SIMNTgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_SIMNTgnu(OPTION_LANG_C) -xc
set tcInfo_SIMNTgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_SIMNTgnu(OPTION_DEPEND) "-M -w"
set tcInfo_SIMNTgnu(CC_ARCH_SPEC) "-mtune=i486 -march=i486"
namespace eval ::tc_SIMNTgnu { }

set tc_SIMNTgnu::tcname(undef_undef) gnu

namespace eval ::tc_SIMNTgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_SIMNTgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_SIMNTgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldpentium $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_SIMNTgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return SIMNT
    }

    proc archDir {} {
	return simnt
    }

    proc name {} {
	return SIMNTgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccpentium -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_SIMNTgnu
}
set tcInfo_SIMSPARCSOLARISgnu(TOOL_FAMILY) gnu
set tcInfo_SIMSPARCSOLARISgnu(CC) "ccsparc"
set tcInfo_SIMSPARCSOLARISgnu(CPP) "ccsparc -E -P"
set tcInfo_SIMSPARCSOLARISgnu(AS) "ccsparc"
set tcInfo_SIMSPARCSOLARISgnu(LD) "ldsparc"
set tcInfo_SIMSPARCSOLARISgnu(LD_PARTIAL) "ccsparc -r -nostdlib -Wl,-X"
set tcInfo_SIMSPARCSOLARISgnu(NM) "nmsparc"
set tcInfo_SIMSPARCSOLARISgnu(SIZE) "sizesparc"
set tcInfo_SIMSPARCSOLARISgnu(AR) "arsparc"
set tcInfo_SIMSPARCSOLARISgnu(CFLAGS) {-g -ansi -fno-builtin -Wall -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SIMSPARCSOLARISgnu(CFLAGS_AS) {-g -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SIMSPARCSOLARISgnu(LDFLAGS) "-X -N"
set tcInfo_SIMSPARCSOLARISgnu(LD_PARTIAL_FLAGS) "-X -r"
set tcInfo_SIMSPARCSOLARISgnu(HEX_FLAGS) ""
set tcInfo_SIMSPARCSOLARISgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_SIMSPARCSOLARISgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_SIMSPARCSOLARISgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_SIMSPARCSOLARISgnu(OPTION_LANG_C) -xc
set tcInfo_SIMSPARCSOLARISgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_SIMSPARCSOLARISgnu(OPTION_DEPEND) "-M -w"
set tcInfo_SIMSPARCSOLARISgnu(CC_ARCH_SPEC) ""
namespace eval ::tc_SIMSPARCSOLARISgnu { }

set tc_SIMSPARCSOLARISgnu::tcname(undef_undef) gnu

namespace eval ::tc_SIMSPARCSOLARISgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_SIMSPARCSOLARISgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_SIMSPARCSOLARISgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldsparc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_SIMSPARCSOLARISgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return SIMSPARCSOLARIS
    }

    proc archDir {} {
	return simsolaris
    }

    proc name {} {
	return SIMSPARCSOLARISgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccsparc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return undef
    }

    proc fp {} {
	return undef
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_SIMSPARCSOLARISgnu
}
set tcInfo_XSCALEgnu(TOOL_FAMILY) gnu
set tcInfo_XSCALEgnu(CC) "ccarm"
set tcInfo_XSCALEgnu(CPP) "ccarm -E -P"
set tcInfo_XSCALEgnu(AS) "ccarm"
set tcInfo_XSCALEgnu(LD) "ldarm"
set tcInfo_XSCALEgnu(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EL"
set tcInfo_XSCALEgnu(NM) "nmarm -g"
set tcInfo_XSCALEgnu(SIZE) "sizearm"
set tcInfo_XSCALEgnu(AR) "ararm"
set tcInfo_XSCALEgnu(CFLAGS) {-g -txscale -ansi -fno-builtin -Wall -DARMEL -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_XSCALEgnu(CFLAGS_AS) {-g -txscale -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_XSCALEgnu(LDFLAGS) "-X -EL -N"
set tcInfo_XSCALEgnu(LD_PARTIAL_FLAGS) "-X -EL -r"
set tcInfo_XSCALEgnu(HEX_FLAGS) ""
set tcInfo_XSCALEgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_XSCALEgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_XSCALEgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_XSCALEgnu(OPTION_LANG_C) -xc
set tcInfo_XSCALEgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_XSCALEgnu(OPTION_DEPEND) "-M -w"
set tcInfo_XSCALEgnu(CC_ARCH_SPEC) "-txscale"
namespace eval ::tc_XSCALEgnu { }

set tc_XSCALEgnu::tcname(little_soft) gnu

namespace eval ::tc_XSCALEgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_XSCALEgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_XSCALEgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_XSCALEgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return XSCALE
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return XSCALEgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return little
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_XSCALEgnu
}
set tcInfo_XSCALEgnube(TOOL_FAMILY) gnu
set tcInfo_XSCALEgnube(CC) "ccarm"
set tcInfo_XSCALEgnube(CPP) "ccarm -E -P"
set tcInfo_XSCALEgnube(AS) "ccarm"
set tcInfo_XSCALEgnube(LD) "ldarm"
set tcInfo_XSCALEgnube(LD_PARTIAL) "ccarm -r -nostdlib -Wl,-X -Wl,-EB"
set tcInfo_XSCALEgnube(NM) "nmarm -g"
set tcInfo_XSCALEgnube(SIZE) "sizearm"
set tcInfo_XSCALEgnube(AR) "ararm"
set tcInfo_XSCALEgnube(CFLAGS) {-g -txscalebe -Wa,-EB -ansi -fno-builtin -Wall -DARMEB -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_XSCALEgnube(CFLAGS_AS) {-g -txscalebe -Wa,-EB -ansi -fno-builtin -xassembler-with-cpp -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_XSCALEgnube(LDFLAGS) "-X -EB -N"
set tcInfo_XSCALEgnube(LD_PARTIAL_FLAGS) "-X -EB -r"
set tcInfo_XSCALEgnube(HEX_FLAGS) ""
set tcInfo_XSCALEgnube(OPTION_INCLUDE_DIR) -I
set tcInfo_XSCALEgnube(OPTION_DEFINE_MACRO) -D
set tcInfo_XSCALEgnube(OPTION_UNDEFINE_MACRO) -U
set tcInfo_XSCALEgnube(OPTION_LANG_C) -xc
set tcInfo_XSCALEgnube(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_XSCALEgnube(OPTION_DEPEND) "-M -w"
set tcInfo_XSCALEgnube(CC_ARCH_SPEC) "-txscalebe  -Wa,-EB"
namespace eval ::tc_XSCALEgnu { }

set tc_XSCALEgnu::tcname(big_soft) gnube

namespace eval ::tc_XSCALEgnube::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_XSCALEgnube::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_XSCALEgnube::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldarm $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_XSCALEgnube {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnube
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return XSCALE
    }

    proc archDir {} {
	return arm
    }

    proc name {} {
	return XSCALEgnube
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccarm -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

    proc endian {} {
	return big
    }

    proc fp {} {
	return soft
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_XSCALEgnube
}

set tcInfo_SPARCsfgnu(TOOL_FAMILY) gnu
set tcInfo_SPARCsfgnu(CC) "ccsparc"
set tcInfo_SPARCsfgnu(CPP) "ccsparc -E -P"
set tcInfo_SPARCsfgnu(AS) "ccsparc"
set tcInfo_SPARCsfgnu(LD) "ldsparc"
set tcInfo_SPARCsfgnu(LD_PARTIAL) "ccsparc -g -r -nostdlib -Wl,-X"
set tcInfo_SPARCsfgnu(NM) "nmsparc"
set tcInfo_SPARCsfgnu(SIZE) "sizesparc"
set tcInfo_SPARCsfgnu(AR) "arsparc"
set tcInfo_SPARCsfgnu(CFLAGS) {-g  -ansi -fno-builtin -Wall -mtune=ut699 -msoft-float -mv8 -ffloat-int-mode -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SPARCsfgnu(CFLAGS_AS) {-g  -ansi -fno-builtin -xassembler-with-cpp -mtune=ut699 -msoft-float -mv8 -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SPARCsfgnu(LDFLAGS) "-g -X -N "
#-L\$(TGT_DIR)/lib/sparc/SPARC/gnu -lgcc
set tcInfo_SPARCsfgnu(LD_PARTIAL_FLAGS) "-g -X -r -mtune=ut699 -msoft-float -mv8 "
set tcInfo_SPARCsfgnu(HEX_FLAGS) ""
set tcInfo_SPARCsfgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_SPARCsfgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_SPARCsfgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_SPARCsfgnu(OPTION_LANG_C) -xc
set tcInfo_SPARCsfgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_SPARCsfgnu(OPTION_DEPEND) "-M -w"
set tcInfo_SPARCsfgnu(CC_ARCH_SPEC) "-msoft-float -mtune=ut699 -mv8 "

namespace eval ::tc_SPARCsfgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_SPARCsfgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_SPARCsfgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldsparc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_SPARCsfgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return sfgnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return SPARC
    }

    proc archDir {} {
	return sparc
    }

    proc name {} {
	return SPARCsfgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccsparc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_SPARCsfgnu
}




set tcInfo_SPARCgnu(TOOL_FAMILY) gnu
set tcInfo_SPARCgnu(CC) "ccsparc"
set tcInfo_SPARCgnu(CPP) "ccsparc -E -P"
set tcInfo_SPARCgnu(AS) "ccsparc"
set tcInfo_SPARCgnu(LD) "ldsparc"
set tcInfo_SPARCgnu(LD_PARTIAL) "ccsparc -g -r -nostdlib -Wl,-X"
set tcInfo_SPARCgnu(NM) "nmsparc"
set tcInfo_SPARCgnu(SIZE) "sizesparc"
set tcInfo_SPARCgnu(AR) "arsparc"
set tcInfo_SPARCgnu(CFLAGS) {-g  -ansi -fno-builtin -Wall -mtune=ut699 -mv8 -ffloat-int-mode -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SPARCgnu(CFLAGS_AS) {-g  -ansi -fno-builtin -xassembler-with-cpp -mtune=ut699 -mv8 -D_VSB_CONFIG_FILE=\"$(VSB_CONFIG_FILE)\"}
set tcInfo_SPARCgnu(LDFLAGS) "-g -X -N "
#-L\$(TGT_DIR)/lib/sparc/SPARC/gnu -lgcc
set tcInfo_SPARCgnu(LD_PARTIAL_FLAGS) "-g -X -r -mtune=ut699 -mv8 "
set tcInfo_SPARCgnu(HEX_FLAGS) ""
set tcInfo_SPARCgnu(OPTION_INCLUDE_DIR) -I
set tcInfo_SPARCgnu(OPTION_DEFINE_MACRO) -D
set tcInfo_SPARCgnu(OPTION_UNDEFINE_MACRO) -U
set tcInfo_SPARCgnu(OPTION_LANG_C) -xc
set tcInfo_SPARCgnu(OPTION_GENERATE_DEPENDENCY_FILE) -MD
set tcInfo_SPARCgnu(OPTION_DEPEND) "-M -w"
set tcInfo_SPARCgnu(CC_ARCH_SPEC) " -mtune=ut699 -mv8 "

namespace eval ::tc_SPARCgnu::tool_cc {

    proc type {} {
	return "C/C++ compiler"
    }

    proc inputSuffixes {} {
	return ".c .cxx .cpp .cc .C"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "\$(CC) $flags -c $file"]
    }

    proc toolMacro {} {
	return CC
    }

    proc flagsMacro {} {
	return CFLAGS
    }
}

namespace eval ::tc_SPARCgnu::tool_as {

    proc type {} {
	return assembler
    }

    proc inputSuffixes {} {
	return ".s"
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	set tc [namespace parent]
	if {[${tc}::asmHasCpp]} {
	    return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	}
	global tcInfo_[${tc}::name]
	regsub -all -- " -MD" $flags "" cppFlags
	set tmpFile [file rootname $file]_tmp.s
	return [list "\$(CPP) $cppFlags $file > ${tmpFile}" "\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" "\$(RM) ${tmpFile}"]
    }

    proc toolMacro {} {
	return AS
    }

    proc flagsMacro {} {
	return CFLAGS_AS
    }
}

namespace eval ::tc_SPARCgnu::tool_ld {

    proc type {} {
	return "linker"
    }

    proc inputSuffixes {} {
	return ""
    }

    proc outputFiles {inFile} {
	return [file rootname [file tail $inFile]].o
    }

    proc buildCmds {flags file} {
	return [list "ldsparc $flags -c $file"]
    }

    proc toolMacro {} {
	return LD
    }

    proc flagsMacro {} {
	return LDFLAGS
    }
}

namespace eval ::tc_SPARCgnu {

    proc type {} {
	return C++
    }

    proc tool {} {
	return gnu
    }

    proc family {} {
	return gnu
    }

    proc cpu {} {
	return SPARC
    }

    proc archDir {} {
	return sparc
    }

    proc name {} {
	return SPARCgnu
    }

    proc toolListGet {} {
	return [namespace children [namespace current] tool_*]
    }

    proc toolFindByFile {file} {
	foreach tool [toolListGet] {
	    if {[lsearch [${tool}::inputSuffixes] [file extension $file]] != -1} {
		return $tool
	    }
	}
	prjWarnLog "no tool works on file $file"
	return ""
    }

    proc toolFindByType {type} {
	foreach tool [toolListGet] {
	    if {[${tool}::type] == $type} {
		return $tool
	    }
	}
	prjWarnLog "no tool of type $type"
	return ""
    }

    proc dependFiles {tool flags file} {
	regsub -all -- " -MD" $flags "" cppFlags
	if {[catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || !$bUseQuickScan || [catch {set result [DependencyAnalyzer::GenerateDependenciesFromFile $cppFlags $file]}]} {
	    set result [oldDependFiles $tool $flags $file]
	}
	return $result
    }

    proc oldDependFiles {tool flags file} {

	global tcInfo_[name]

	regsub -all -- " -MD" $flags "" cppFlags
	set errorFile [tempFileGet]
	if {[catch {eval exec ccsparc -E -P -M -w $cppFlags $file 2>  [filenameQuoteIfNecessary $errorFile]} depend]} {
	    set fd [open $errorFile r]
	    set dependError [read $fd]
	    close $fd
	    error "dependency generation failed: $dependError"
	}
	file delete $errorFile
	regsub -all { \\} $depend {} depend
	regsub -all {\\} $depend {\/} depend
	return [lrange $depend 2 end]
    }

    proc macroListGet {} {
	global tcInfo_[name]
	return [array names tcInfo_[name]]
    }

    proc macroDefaultValGet {macro} {
	global tcInfo_[name]
	return [set tcInfo_[name]($macro)]
    }

    proc commSymLink {} {
	switch -glob [archDir] {
	    mc68k {return symbol}
	    default {return module}
	}
    }

    proc defaultWtxDownloadFlags {strFilename} {
	set bufNmOutput {}
	regsub -- -g [macroDefaultValGet NM] {} strCmd
	set bFailed [catch {set bufNmOutput "\n[eval exec $strCmd $strFilename ]" } ]
	if {$bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" $bufNmOutput] } {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
	} else {
	    return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
	}
    }

    proc cPrependChar {} {
	return ""
    }

    proc asmHasCpp {} {
	return 1
    }

}

if {[info commands prjTcAdd] == "prjTcAdd"} {
    prjTcAdd ::tc_SPARCgnu
}
