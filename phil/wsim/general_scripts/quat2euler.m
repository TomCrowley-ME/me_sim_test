%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright 2010 - 2015 Moon Express, Inc.
% All Rights Reserved.
%
% PROPRIETARY DATA NOTICE:
% The data herein include Proprietary Data and are restricted under the
% Data Rights provisions of Lunar CATALYST Space Act Agreement
% No. SAAM ID# 18251 and Reimbursable Space Act Agreement No.SAA2-402930.
% All information contained herein is and remains proprietary to and the
% property of Moon Express, Inc. Dissemination of this information or
% reproduction of this material is strictly forbidden unless prior
% written permission is obtained from Moon Express, Inc.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%-------------------------------------------------------------------------%% quat2euler.m                                                            %%                                                                         %% Vectorized version of scalar part last quaternion to euler conversion   %% Euler rotation sequence used in 'zyx'                                   %%                                                                         %% Input: q (row vector)                                                   %% Output: [phi theta psi] (xyz rotation) in radians                       %%                                                                         %% 03/31/12v                                                               %%-------------------------------------------------------------------------%function [ lander_euler_xyz ] = quat2euler(quat_in)% This is a useful utility for plotting that accepts 4 by 1 quaternion vector % and returns 3 by 1 Euler angle vector.  The fourth number in the% quaternion is a scalar.  The euler angle outputs are in order of [z y x]if isa(quat_in,'timeseries')        quat = [quat_in.Data(:,4) quat_in.Data(:,1:3)];    else        quat = [quat_in(:,4) quat_in(:,1:3)];end% Rot_matx = [(1 - 2*(quat(3,1))^2 - 2*(quat(4,1))^2) (2*quat(2,1)*quat(3,1) - 2*quat(4,1)*quat(1,1)) (2*quat(2,1)*quat(4,1) + 2*quat(3,1)*quat(1,1));...% %             (2*quat(2,1)*quat(3,1) + 2*quat(4,1)*quat(1,1)) (1 - 2*(quat(2,1))^2 - 2*(quat(4,1))^2) (2*quat(3,1)*quat(4,1) - 2*quat(2,1)*quat(1,1));...% %             (2*quat(2,1)*quat(4,1) - 2*quat(3,1)*quat(1,1)) (2*quat(3,1)*quat(4,1) + 2*quat(2,1)*quat(1,1)) (1 - 2*(quat(2,1))^2 - 2*(quat(3,1))^2)];R11 = (1 - 2*(quat(:,3)).^2 - 2*(quat(:,4)).^2);R12 = (2*quat(:,2).*quat(:,3) - 2*quat(:,4).*quat(:,1));R21 = (2*quat(:,2).*quat(:,3) + 2*quat(:,4).*quat(:,1));R31 = (2*quat(:,2).*quat(:,4) - 2*quat(:,3).*quat(:,1));R32 = (2*quat(:,3).*quat(:,4) + 2*quat(:,2).*quat(:,1));R33 = (1 - 2*(quat(:,2)).^2 - 2*(quat(:,3)).^2);R11( R11 > 1 ) = 1; R11( R11 < -1 ) = -1;R21( R21 > 1 ) = 1; R21( R21 < -1 ) = -1;R31( R31 > 1 ) = 1; R31( R31 < -1 ) = -1;R32( R32 > 1 ) = 1; R32( R32 < -1 ) = -1;R33( R33 > 1 ) = 1; R33( R33 < -1 ) = -1;theta = asin(-R31);sin_phi = R32./cos(theta);cos_phi = R33./cos(theta);phi = asin( sin_phi ) ;phi( sin_phi >= 0 & cos_phi < 0 ) = +pi - phi( sin_phi >= 0 & cos_phi < 0 );phi( sin_phi <  0 & cos_phi < 0 ) = -pi - phi( sin_phi <  0 & cos_phi < 0 );sin_psi = R21./cos(theta);cos_psi = R11./cos(theta);psi = asin( sin_psi ) ;psi( sin_psi >= 0 & cos_psi < 0 ) = +pi - psi( sin_psi >= 0 & cos_psi < 0 );psi( sin_psi <  0 & cos_psi < 0 ) = -pi - psi( sin_psi <  0 & cos_psi < 0 );lander_euler_xyz = [ phi theta psi ];if isa(quat_in,'timeseries')    lander_euler_xyz = timeseries(lander_euler_xyz, quat_in.Time, 'name',['eul_' quat_in.Name]);end